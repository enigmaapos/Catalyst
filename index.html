<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Catalyst NFT Staking DApp</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <style>
    body { font-family: Arial, sans-serif; background:#111; color:#eee; padding:20px; }
    input, select, button { margin:4px; padding:6px; }
    button { cursor:pointer; }
    .logline { font-size:12px; }
    .ok { color:lightgreen; }
    .err { color:tomato; }
    pre { background:#222; padding:8px; }
  </style>
</head>
<body>
  <h1>Catalyst NFT Staking</h1>
  <button id="walletBtn" onclick="connectWallet()">Connect Wallet</button>
  <span id="acct"></span>

  <h2>Register Collection</h2>
  <input id="colReg" placeholder="Collection address">
  <input id="maxSupply" type="number" placeholder="Max supply ≤ 20000">
  <button onclick="registerCollection()">Register</button>

  <h2>Stake / Unstake</h2>
  <input id="colStake" placeholder="Collection address">
  <input id="tidStake" placeholder="Token ID">
  <select id="permanent"><option value="false">Term</option><option value="true">Permanent</option></select>
  <button onclick="stakeNFT()">Stake</button>
  <button onclick="unstakeNFT()">Unstake</button>
  <button onclick="harvestOne()">Harvest One</button>
  <button onclick="viewPendingReward()">View Pending Reward</button>
  <p id="pendingView"></p>

  <h2>Batch Stake</h2>
  <input id="colBatch" placeholder="Collection address">
  <input id="tidBatch" placeholder="Token IDs (comma-separated)">
  <select id="permanentBatch"><option value="false">Term</option><option value="true">Permanent</option></select>
  <button onclick="batchStakeNFT()">Batch Stake</button>

  <h2>Bluechip</h2>
  <button onclick="enrollBluechip()">Enroll</button>
  <input id="colBlueHarvest" placeholder="Collection address">
  <button onclick="harvestBluechip()">Harvest Bluechip</button>
  <input id="colFlagBlue" placeholder="Collection address">
  <select id="isBlueFlag"><option value="true">True</option><option value="false">False</option></select>
  <button onclick="setBlueChip()">Set Bluechip</button>

  <h2>Governance</h2>
  <select id="pType">
    <option value="0">RewardRateChange</option>
    <option value="1">CollectionLimitChange</option>
    <option value="2">TreasuryWithdraw</option>
  </select>
  <input id="paramTarget" placeholder="Target">
  <input id="newValue" placeholder="New Value">
  <input id="collCtx" placeholder="Context address (optional)">
  <button onclick="propose()">Propose</button>
  <input id="propId" placeholder="Proposal ID">
  <button onclick="voteProposal()">Vote</button>
  <button onclick="executeProposal()">Execute</button>

  <h2>Admin</h2>
  <button onclick="pauseContract()">Pause</button>
  <button onclick="unpauseContract()">Unpause</button>
  <input id="toTreasury" placeholder="To address">
  <input id="amtTreasury" placeholder="Amount">
  <button onclick="withdrawTreasury()">Withdraw Treasury</button>

  <h2>Stats</h2>
  <button onclick="refreshStats()">Refresh Stats</button>
  <p>Total All: <span id="st_totalAll"></span></p>
  <p>Total Term: <span id="st_totalTerm"></span></p>
  <p>Total Permanent: <span id="st_totalPermanent"></span></p>
  <p>Remaining Global: <span id="st_remainingGlobal"></span></p>
  <p>Remaining Term: <span id="st_remainingTerm"></span></p>
  <p>Remaining Permanent: <span id="st_remainingPermanent"></span></p>
  <p>Treasury Balance: <span id="st_treasury"></span></p>

  <h2>Info</h2>
  <input id="infoUser" placeholder="User address (optional)">
  <button onclick="viewUserInfo()">View User Info</button>
  <input id="infoCol" placeholder="Collection address">
  <button onclick="viewCollectionInfo()">View Collection Info</button>
  <pre id="infoOut"></pre>

  <h2>Logs</h2>
  <div id="log"></div>

  <!-- ethers v5 -->
  <script src="https://cdn.ethers.io/lib/ethers-5.2.umd.min.js"></script>
  <script>
  const ABI_URL = "../abi/CatalystNFTStakingUpgradeable.json";
  const DEFAULT_CONTRACT = "0xF6f4B2eb6b9D4e87fA5D38DE9124Dd4C212a61FD";
  const DEFAULT_RPC = "https://rpc.test.btcs.network/";
  let provider, signer, userAddr, contract, abi;

  const $ = id => document.getElementById(id);
  function log(msg, cls="") {
    const el = $("log"); if (!el) return;
    const div = document.createElement("div");
    div.className = "logline " + cls;
    div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    el.prepend(div); console.log(msg);
  }
  function parseAddr(v) { if (!ethers.utils.isAddress(v)) throw new Error("Invalid address"); return v; }
  function parseBig(v) { return ethers.BigNumber.from(v.toString().trim() || "0"); }

  async function loadABI() {
    if (abi) return abi;
    const res = await fetch(ABI_URL); abi = await res.json(); return abi;
  }
  async function initContract(write=false) {
    const _abi = await loadABI();
    if (write) {
      provider = new ethers.providers.Web3Provider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      signer = provider.getSigner(); userAddr = await signer.getAddress();
      contract = new ethers.Contract(DEFAULT_CONTRACT, _abi, signer);
    } else {
      provider = new ethers.providers.JsonRpcProvider(DEFAULT_RPC);
      contract = new ethers.Contract(DEFAULT_CONTRACT, _abi, provider);
    }
    return contract;
  }
  async function connectWallet() {
    await initContract(true);
    $("acct").textContent = userAddr; $("walletBtn").textContent = "Disconnect";
    log(`Wallet connected: ${userAddr}`,"ok");
  }

  /* === Read Functions === */
  async function refreshStats() {
    try {
      await initContract(false); const s = await contract.stakingStats();
      $("st_totalAll").textContent = s.totalAll; $("st_totalTerm").textContent = s.totalTerm;
      $("st_totalPermanent").textContent = s.totalPermanent;
      $("st_remainingGlobal").textContent = s.remainingGlobal;
      $("st_remainingTerm").textContent = s.remainingTerm;
      $("st_remainingPermanent").textContent = s.remainingPermanent;
      const t = await contract.treasuryBalance();
      $("st_treasury").textContent = ethers.utils.formatUnits(t,18);
      log("Stats refreshed ✅","ok");
    } catch(e){log(e.message,"err");}
  }
  async function viewPendingReward() {
    try {
      await initContract(false);
      const col=parseAddr($("colStake").value.trim()), id=parseBig($("tidStake").value);
      const r=await contract.pendingRewardOf(col,id);
      $("pendingView").textContent=ethers.utils.formatUnits(r,18)+" CATA";
    } catch(e){log(e.message,"err");}
  }
  async function viewUserInfo() {
    try {
      await initContract(false);
      const who=$("infoUser").value.trim()||userAddr, addr=parseAddr(who);
      const c=await contract.userStakeCount(addr), en=await contract.isBluechipEnrolled(addr);
      $("infoOut").textContent=`User: ${addr}\nStakeCount: ${c}\nBluechip: ${en}`;
    } catch(e){log(e.message,"err");}
  }
  async function viewCollectionInfo() {
    try {
      await initContract(false);
      const col=parseAddr($("infoCol").value.trim()), info=await contract.collectionInfo(col);
      $("infoOut").textContent=`Collection: ${col}\nMaxSupply: ${info.maxSupply}\nVerified: ${info.verified}\nBluechip: ${info.isBlue}`;
    } catch(e){log(e.message,"err");}
  }

  /* === Write Functions === */
  async function registerCollection(){try{await initContract(true);
    const col=parseAddr($("colReg").value.trim()),sup=parseBig($("maxSupply").value);
    const tx=await contract.registerCollection(col,sup); log(`Tx: ${tx.hash}`); await tx.wait(); log("Collection registered ✅","ok");
  }catch(e){log(e.message,"err");}}
  async function stakeNFT(){try{await initContract(true);
    const col=parseAddr($("colStake").value.trim()),id=parseBig($("tidStake").value),isPerm=$("permanent").value==="true";
    const tx=await contract.stake(col,id,isPerm); log(`Stake: ${tx.hash}`); await tx.wait(); log("NFT staked ✅","ok");
  }catch(e){log(e.message,"err");}}
  async function batchStakeNFT(){try{await initContract(true);
    const col=parseAddr($("colBatch").value.trim()),ids=$("tidBatch").value.split(",").map(x=>parseBig(x)),isPerm=$("permanentBatch").value==="true";
    const tx=await contract.batchStake(col,ids,isPerm); log(`Batch: ${tx.hash}`); await tx.wait(); log("Batch stake ✅","ok");
  }catch(e){log(e.message,"err");}}
  async function unstakeNFT(){try{await initContract(true);
    const col=parseAddr($("colStake").value.trim()),id=parseBig($("tidStake").value);
    const tx=await contract.unstake(col,id); log(`Unstake: ${tx.hash}`); await tx.wait(); log("Unstaked ✅","ok");
  }catch(e){log(e.message,"err");}}
  async function harvestOne(){try{await initContract(true);
    const col=parseAddr($("colStake").value.trim()),id=parseBig($("tidStake").value);
    const tx=await contract.harvestOne(col,id); log(`Harvest: ${tx.hash}`); await tx.wait(); log("Harvested ✅","ok");
  }catch(e){log(e.message,"err");}}

  async function enrollBluechip(){try{await initContract(true);
    const tx=await contract.enrollBluechip(); log(`Enroll: ${tx.hash}`); await tx.wait(); log("Enrolled ✅","ok");
  }catch(e){log(e.message,"err");}}
  async function harvestBluechip(){try{await initContract(true);
    const col=parseAddr($("colBlueHarvest").value.trim());
    const tx=await contract.harvestBluechip(col); log(`Harvest BC: ${tx.hash}`); await tx.wait(); log("Bluechip harvested ✅","ok");
  }catch(e){log(e.message,"err");}}
  async function setBlueChip(){try{await initContract(true);
    const col=parseAddr($("colFlagBlue").value.trim()),flag=$("isBlueFlag").value==="true";
    const tx=await contract.setBlueChip(col,flag); log(`Set BC: ${tx.hash}`); await tx.wait(); log("Bluechip set ✅","ok");
  }catch(e){log(e.message,"err");}}

  const ProposalTypes={RewardRateChange:0,CollectionLimitChange:1,TreasuryWithdraw:2};
  async function propose(){try{await initContract(true);
    const typeStr=$("pType").value,pType=ProposalTypes[typeStr]??parseInt(typeStr),target=parseBig($("paramTarget").value),val=parseBig($("newValue").value),ctx=$("collCtx").value.trim()||ethers.constants.AddressZero;
    const tx=await contract.propose(pType,target,val,ctx); log(`Propose: ${tx.hash}`); await tx.wait(); log("Proposal ✅","ok");
  }catch(e){log(e.message,"err");}}
  async function voteProposal(){try{await initContract(true);
    const id=parseBig($("propId").value); const tx=await contract.vote(id); log(`Vote: ${tx.hash}`); await tx.wait(); log("Voted ✅","ok");
  }catch(e){log(e.message,"err");}}
  async function executeProposal(){try{await initContract(true);
    const id=parseBig($("propId").value); const tx=await contract.execute(id); log(`Exec: ${tx.hash}`); await tx.wait(); log("Executed ✅","ok");
  }catch(e){log(e.message,"err");}}

  async function pauseContract(){try{await initContract(true);
    const tx=await contract.pause(); log(`Pause: ${tx.hash}`); await tx.wait(); log("Paused ✅","ok");
  }catch(e){log(e.message,"err");}}
  async function unpauseContract(){try{await initContract(true);
    const tx=await contract.unpause(); log(`Unpause: ${tx.hash}`); await tx.wait(); log("Unpaused ✅","ok");
  }catch(e){log(e.message,"err");}}
  async function withdrawTreasury(){try{await initContract(true);
    const to=parseAddr($("toTreasury").value.trim()),amt=parseBig($("amtTreasury").value);
    const tx=await contract.withdrawTreasury(to,amt); log(`Withdraw: ${tx.hash}`); await tx.wait(); log("Withdrawn ✅","ok");
  }catch(e){log(e.message,"err");}}
  </script>
</body>
</html>
