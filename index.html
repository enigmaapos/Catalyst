<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catalyst NFT Staking DApp</title>
    <script src="https://cdn.ethers.io/5.7.2/ethers.umd.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            display: flex;
            justify-content: center;
        }
        .container {
            background-color: #fff;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            max-width: 900px;
            width: 100%;
        }
        h1, h2, h3 {
            color: #2c3e50;
            text-align: center;
        }
        .section {
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 20px;
            margin-bottom: 20px;
        }
        .section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        .input-group {
            margin-bottom: 15px;
        }
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .input-group input, .input-group select {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            box-sizing: border-box;
        }
        .button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            color: #fff;
        }
        .button.connect {
            background-color: #3498db;
        }
        .button.read {
            background-color: #2ecc71;
        }
        .button.write {
            background-color: #e74c3c;
        }
        .function-item {
            display: grid;
            grid-template-columns: 1fr 2fr 100px;
            gap: 15px;
            align-items: center;
            padding: 15px;
            border: 1px solid #f0f0f0;
            border-radius: 8px;
            margin-bottom: 10px;
            background-color: #fafafa;
        }
        .function-item h4 {
            margin: 0;
            font-size: 1.1em;
            color: #2c3e50;
        }
        .function-inputs {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .result {
            margin-top: 10px;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
            word-wrap: break-word;
        }
        .status {
            text-align: center;
            font-weight: bold;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Catalyst NFT Staking DApp</h1>

    <div class="section">
        <h3>1. Connect Wallet</h3>
        <button id="connectWalletBtn" class="button connect">Connect Wallet</button>
        <div class="status">Connected: <span id="accountAddress">Not connected</span></div>
    </div>

    <div class="section">
        <h3>2. Set Contract Address</h3>
        <div class="input-group">
            <label for="contractAddress">Contract Address:</label>
            <input type="text" id="contractAddress" placeholder="0x..." />
        </div>
        <button id="loadContractBtn" class="button">Load Contract</button>
    </div>

    <div class="section" id="readFunctionsSection" style="display: none;">
        <h2>Read Functions (View)</h2>
        <div id="readFunctionsList"></div>
    </div>

    <div class="section" id="writeFunctionsSection" style="display: none;">
        <h2>Write Functions (Send)</h2>
        <div id="writeFunctionsList"></div>
    </div>

    <div class="section">
        <h2>Logs</h2>
        <pre id="logs" style="background-color: #2c3e50; color: #fff; padding: 10px; border-radius: 5px; overflow-x: auto;"></pre>
    </div>
</div>

<script>
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();
    let contract;
    let abi;

    const log = (message, isError = false) => {
        const logsEl = document.getElementById('logs');
        const formattedMessage = isError ? `❌ ${message}` : `✅ ${message}`;
        logsEl.textContent += `${formattedMessage}\n`;
        logsEl.scrollTop = logsEl.scrollHeight;
    };

    const getContractABI = () => {
        // This is a simplified ABI generated from your function selectors.
        // It provides enough information for ethers.js to interact with the contract.
        return [
            "function TREASURY_BP() view returns (uint256)",
            "function registerCollection(address _collection, uint256 _declaredSupply)",
            "function unstakeBatch(address _collection, uint256[] _tokenIds)",
            "function propose(uint8 _pType, uint8 _paramTarget, uint256 _newValue, address _collectionAddress)",
            "function BP_DENOM() view returns (uint256)",
            "function BURN_BP() view returns (uint256)",
            "function CONTRACT_ADMIN_ROLE() view returns (bytes32)",
            "function DEFAULT_ADMIN_ROLE() view returns (bytes32)",
            "function DEPLOYER_BP() view returns (uint256)",
            "function GLOBAL_CAP() view returns (uint256)",
            "function MAX_HARVEST_BATCH() view returns (uint256)",
            "function MAX_STAKE_PER_COLLECTION() view returns (uint256)",
            "function PERM_CAP() view returns (uint256)",
            "function RECOVERY_WINDOW() view returns (uint256)",
            "function TERM_CAP() view returns (uint256)",
            "function UPGRADE_INTERFACE_VERSION() view returns (bytes32)",
            "function WEIGHT_SCALE() view returns (uint256)",
            "function allowance(address owner, address spender) view returns (uint256)",
            "function approve(address spender, uint256 amount)",
            "function approveAdminRecovery()",
            "function approveDeployerRecovery()",
            "function balanceOf(address account) view returns (uint256)",
            "function batchStake(address _collection, uint256[] _tokenIds, bool _isPermanent)",
            "function burnedCatalystByAddress(address _address) view returns (uint256)",
            "function collectionCount() view returns (uint256)",
            "function collectionRegistrationFee() view returns (uint256)",
            "function collectionTotalStaked(address _collection) view returns (uint256)",
            "function decimals() view returns (uint8)",
            "function deployerAddress() view returns (address)",
            "function enrollBluechip()",
            "function executeAdminRecovery()",
            "function executeDeployerRecovery()",
            "function executeProposal(bytes32 _id)",
            "function getCollectionTier(address _collection) view returns (uint8)",
            "function getRoleAdmin(bytes32 role) view returns (bytes32)",
            "function grantRole(bytes32 role, address account)",
            "function harvest(address _collection, uint256 _tokenId)",
            "function harvestBatch(address _collection, uint256[] _tokenIds)",
            "function harvestBluechip(address _collection)",
            "function hasRole(bytes32 role, address account) view returns (bool)",
            "function initialHarvestBurnFeeRate() view returns (uint256)",
            "function initialize((address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address[],uint256,address[],uint256,uint256))",
            "function isBluechipCollection(address _collection) view returns (bool)",
            "function isBluechipEnrolled(address _collection, address _wallet) view returns (bool)",
            "function isCollectionRegistered(address _collection) view returns (bool)",
            "function lastStakingBlock(address _staker) view returns (uint256)",
            "function maxBaseRewardRate() view returns (uint256)",
            "function minStakeAgeForVoting() view returns (uint256)",
            "function name() view returns (string)",
            "function numberOfBlocksPerRewardUnit() view returns (uint256)",
            "function onERC721Received(address operator, address from, uint256 tokenId, bytes data) external override returns (bytes4)",
            "function pause()",
            "function paused() view returns (bool)",
            "function pendingRewardsView(address _collection, address _owner, uint256 _tokenId) view returns (uint256)",
            "function proposeAdminRecovery(address _proposed)",
            "function proposeDeployerRecovery(address _proposed)",
            "function proxiableUUID() view returns (bytes32)",
            "function registeredCollections(uint256) view returns (address)",
            "function registeredIndex(address _collection) view returns (uint256)",
            "function renounceRole(bytes32 role, address account)",
            "function revokeRole(bytes32 role, address account)",
            "function rewardRateIncrementPerNFT() view returns (uint256)",
            "function setAdminGuardian(uint8 _idx, address _guardian)",
            "function setBluechipCollection(address _collection, bool _isBluechip)",
            "function setDeployerGuardian(uint8 _idx, address _guardian)",
            "function stake(address _collection, uint256 _tokenId, bool _isPermanent)",
            "function stakingCooldownBlocks() view returns (uint256)",
            "function stakingStats() view returns (uint256 totalStakedAll, uint256 totalStakedTerm, uint256 totalStakedPermanent)",
            "function supportsInterface(bytes4 interfaceId) view returns (bool)",
            "function symbol() view returns (string)",
            "function termDurationBlocks() view returns (uint256)",
            "function totalSupply() view returns (uint256)",
            "function transfer(address to, uint256 amount)",
            "function transferFrom(address from, address to, uint256 amount)",
            "function treasuryAddress() view returns (address)",
            "function treasuryBalance() view returns (uint256)",
            "function unpause()",
            "function unstake(address _collection, uint256 _tokenId)",
            "function unstakeBurnFee() view returns (uint256)",
            "function upgradeToAndCall(address newImplementation, bytes data)",
            "function vote(bytes32 _id)",
            "function withdrawTreasury(address _to, uint256 _amount)"
        ];
    };

    const parseSignature = (signature) => {
        const match = signature.match(/^(\w+)\(([^)]*)\)(?:.*)/);
        if (!match) return null;
        const name = match[1];
        const inputs = match[2].split(',').filter(p => p.trim() !== '').map(p => {
            const parts = p.trim().split(' ');
            return {
                type: parts[0],
                name: parts[1] || `param${Math.random().toString(36).substr(2, 5)}`
            };
        });
        const isView = signature.includes('view') || signature.includes('pure');
        return {
            name,
            inputs,
            isView
        };
    };

    const renderFunctions = () => {
        const abi = getContractABI();
        const readList = document.getElementById('readFunctionsList');
        const writeList = document.getElementById('writeFunctionsList');
        const readSection = document.getElementById('readFunctionsSection');
        const writeSection = document.getElementById('writeFunctionsSection');
        readList.innerHTML = '';
        writeList.innerHTML = '';

        abi.forEach(item => {
            const func = parseSignature(item);
            if (!func) return;

            const funcItem = document.createElement('div');
            funcItem.className = 'function-item';

            const funcNameEl = document.createElement('h4');
            funcNameEl.textContent = func.name;
            funcItem.appendChild(funcNameEl);

            const inputsEl = document.createElement('div');
            inputsEl.className = 'function-inputs';
            const argInputs = func.inputs.map(input => {
                const inputEl = document.createElement('input');
                inputEl.type = "text";
                inputEl.placeholder = `${input.name} (${input.type})`;
                inputEl.dataset.type = input.type;
                inputsEl.appendChild(inputEl);
                return inputEl;
            });
            funcItem.appendChild(inputsEl);

            const button = document.createElement('button');
            const resultEl = document.createElement('div');
            resultEl.className = 'result';
            resultEl.style.display = 'none';
            funcItem.appendChild(resultEl);

            if (func.isView) {
                button.textContent = "Call";
                button.className = "button read";
                button.onclick = async () => {
                    resultEl.style.display = 'block';
                    resultEl.textContent = "Calling...";
                    try {
                        const args = argInputs.map(input => {
                            if (input.dataset.type.includes('[]')) {
                                return JSON.parse(`[${input.value}]`);
                            }
                            return input.value;
                        });
                        const result = await contract[func.name](...args);
                        resultEl.textContent = `Result: ${result.toString()}`;
                        log(`Called ${func.name}: ${result.toString()}`);
                    } catch (err) {
                        resultEl.textContent = `Error: ${err.message}`;
                        log(`Error calling ${func.name}: ${err.message}`, true);
                    }
                };
                readList.appendChild(funcItem);
            } else {
                button.textContent = "Send";
                button.className = "button write";
                button.onclick = async () => {
                    try {
                        const args = argInputs.map(input => {
                            if (input.dataset.type.includes('[]')) {
                                return JSON.parse(`[${input.value}]`);
                            }
                            return input.value;
                        });
                        const tx = await contract[func.name](...args);
                        resultEl.style.display = 'block';
                        resultEl.textContent = `Transaction sent! Hash: ${tx.hash}`;
                        log(`Transaction sent for ${func.name}: ${tx.hash}`);
                        await tx.wait();
                        resultEl.textContent += `\nTransaction mined!`;
                        log(`Transaction mined for ${func.name}`);
                    } catch (err) {
                        resultEl.textContent = `Error: ${err.message}`;
                        log(`Error sending transaction for ${func.name}: ${err.message}`, true);
                    }
                };
                writeList.appendChild(funcItem);
            }
            funcItem.appendChild(button);
        });

        readSection.style.display = 'block';
        writeSection.style.display = 'block';
    };

    document.getElementById('connectWalletBtn').addEventListener('click', async () => {
        if (typeof window.ethereum === 'undefined') {
            log('MetaMask not detected. Please install it to use this DApp.', true);
            return;
        }
        try {
            const accounts = await provider.send("eth_requestAccounts", []);
            document.getElementById('accountAddress').textContent = accounts[0];
            log(`Wallet connected: ${accounts[0]}`);
        } catch (error) {
            log(`Wallet connection failed: ${error.message}`, true);
        }
    });

    document.getElementById('loadContractBtn').addEventListener('click', () => {
        const address = document.getElementById('contractAddress').value;
        if (!ethers.utils.isAddress(address)) {
            log('Invalid contract address.', true);
            return;
        }
        try {
            abi = getContractABI();
            contract = new ethers.Contract(address, abi, signer);
            log(`Contract loaded at address: ${address}`);
            renderFunctions();
        } catch (error) {
            log(`Failed to load contract: ${error.message}`, true);
        }
    });
</script>
</body>
</html>
