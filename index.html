<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Catalyst DApp — Dashboard</title>
  <link rel="stylesheet" href="/css/styles.css" />
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.8.0/dist/ethers.min.js"></script>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--muted:#9aa4b2;--accent:#7c3aed}
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Arial;background:linear-gradient(180deg,#071029,#071320);color:#e6eef6}
    .app{display:flex;gap:1rem;padding:20px;max-width:1200px;margin:0 auto}
    aside{width:300px;background:var(--card);padding:16px;border-radius:12px;box-shadow:0 6px 24px rgba(0,0,0,.6)}
    main{flex:1;background:rgba(255,255,255,0.02);padding:16px;border-radius:12px}
    h1,h2{margin:.2rem 0}
    button{background:var(--accent);border:none;padding:8px 12px;border-radius:8px;color:white;cursor:pointer}
    .row{display:flex;gap:8px;align-items:center}
    .card{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;margin-bottom:12px}
    textarea{width:100%;height:200px;background:#071020;color:#dbe9ff;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
    input,select,pre{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    input[type="text"]{width:100%}
    .small{font-size:13px;color:var(--muted)}
    pre{white-space:pre-wrap;word-break:break-word}
    .muted{color:var(--muted)}
    .mutedBlock{background:rgba(255,255,255,0.01);padding:10px;border-radius:8px}
  </style>
</head>
<body>
  <div class="app">
    <aside>
      <h2>Catalyst (CATA)</h2>
      <p class="small">Universal NFT staking & governance — dashboard</p>

      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center">
          <div>
            <button id="connectBtn">Connect Wallet</button>
          </div>
          <div style="text-align:right">
            <div id="address" class="small muted">not connected</div>
            <div id="network" class="small muted">network: unknown</div>
          </div>
        </div>
      </div>

      <div class="card">
        <h3 class="small">Quick actions</h3>
        <div style="display:flex;flex-direction:column;gap:8px;margin-top:8px">
          <button onclick="ui.showTab('overview')">Overview</button>
          <button onclick="ui.showTab('stake')">Stake NFT</button>
          <button onclick="ui.showTab('batch')">Batch Stake</button>
          <button onclick="ui.showTab('bluechip')">Bluechip</button>
          <button onclick="ui.showTab('governance')">Governance</button>
          <button onclick="ui.showTab('admin')">Admin</button>
          <button onclick="ui.showTab('contract')">Contract / ABI</button>
          <button onclick="ui.showTab('whitepaper')">Whitepaper</button>
        </div>
      </div>

      <div class="card">
        <h3 class="small">Stats</h3>
        <div class="small muted">Treasury: <span id="treasury">-</span></div>
        <div class="small muted">Total Registered: <span id="totalRegistered">-</span></div>
        <div class="small muted">Burned (you): <span id="burnedByAddress">-</span></div>
      </div>
    </aside>

    <main>
      <div id="tabs">

        <!-- Overview -->
        <section id="overview" class="tab">
          <h1>Overview</h1>
          <p class="small muted">Protocol summary and live stats</p>

          <div class="row">
            <div class="card" style="flex:1">
              <h3 class="small">Protocol</h3>
              <div class="small">Global cap: <strong id="globalCap">-</strong></div>
              <div class="small">Per-collection cap: <strong id="collectionCap">-</strong></div>
              <div class="small">Registration fee: <strong id="regFee">-</strong></div>
            </div>

            <div class="card" style="flex:1">
              <h3 class="small">Your portfolio</h3>
              <div class="small">CATA balance: <span id="cataBalance">-</span></div>
              <div class="small">Staked NFTs (total): <span id="stakedCount">-</span></div>
            </div>
          </div>
        </section>

        <!-- Stake -->
        <section id="stake" class="tab" style="display:none">
          <h1>Stake NFT (custodial)</h1>
          <div class="card">
            <div class="small">Collection (ERC-721 address)</div>
            <input type="text" id="stakeCollection" placeholder="0x..." />
            <div class="small" style="margin-top:8px">Token ID</div>
            <input type="text" id="stakeTokenId" placeholder="1234" />
            <div style="margin-top:8px" class="row">
              <label class="small"><input id="stakePermanent" type="checkbox" /> Permanent stake</label>
              <button onclick="actions.stake()">Stake</button>
              <div id="stakeResult" class="small muted"></div>
            </div>
          </div>
        </section>

        <!-- Batch stake -->
        <section id="batch" class="tab" style="display:none">
          <h1>Batch Stake</h1>
          <div class="card">
            <div class="small">Collection</div>
            <input type="text" id="batchCollection" placeholder="0x..." />
            <div class="small" style="margin-top:8px">Token IDs (comma separated)</div>
            <input type="text" id="batchTokenIds" placeholder="1,2,3,4" />
            <div style="margin-top:8px" class="row">
              <label class="small"><input id="batchPermanent" type="checkbox" /> Permanent</label>
              <button onclick="actions.batchStake()">Batch Stake</button>
              <div id="batchResult" class="small muted"></div>
            </div>
          </div>
        </section>

        <!-- Bluechip -->
        <section id="bluechip" class="tab" style="display:none">
          <h1>Bluechip Enrollment / Harvest</h1>
          <div class="card">
            <div class="small">Enroll wallet for bluechip rewards</div>
            <button onclick="actions.enrollBluechip()">Enroll Wallet</button>
            <div class="small muted" id="enrollResult"></div>
          </div>

          <div class="card">
            <div class="small">Harvest rewards for bluechip collection</div>
            <input type="text" id="blueHarvestCollection" placeholder="0x..." />
            <button onclick="actions.harvestBluechip()">Harvest</button>
            <div class="small muted" id="blueHarvestResult"></div>
          </div>
        </section>

        <!-- Governance -->
        <section id="governance" class="tab" style="display:none">
          <h1>Governance</h1>

          <div class="card">
            <h3 class="small">Create Proposal</h3>
            <div class="small">Type</div>
            <select id="proposalType">
              <option value="0">BASE_REWARD</option>
              <option value="1">VOTING_PARAM</option>
            </select>
            <div class="small" style="margin-top:8px">Param target (numeric)</div>
            <input type="text" id="proposalParam" placeholder="e.g. 0"/>
            <div class="small" style="margin-top:8px">New value</div>
            <input type="text" id="proposalValue" placeholder="e.g. 1000"/>
            <div class="small" style="margin-top:8px">Collection context (optional)</div>
            <input type="text" id="proposalContext" placeholder="0x... or leave blank" />
            <div style="margin-top:8px" class="row">
              <button onclick="actions.propose()">Propose</button>
              <div id="proposeResult" class="small muted"></div>
            </div>
          </div>

          <div class="card">
            <h3 class="small">Vote / Execute</h3>
            <div class="small">Proposal ID (bytes32)</div>
            <input type="text" id="voteId" placeholder="0x..." />
            <div class="row" style="margin-top:8px">
              <button onclick="actions.vote()">Vote</button>
              <button onclick="actions.executeProposal()">Execute</button>
              <div id="voteResult" class="small muted"></div>
            </div>
          </div>
        </section>

        <!-- Admin -->
        <section id="admin" class="tab" style="display:none">
          <h1>Admin / Guardians</h1>

          <div class="card">
            <h3 class="small">Guardians (Show)</h3>
            <div class="small">Click to read deployer & admin guardians (7 each)</div>
            <div style="margin-top:8px" class="row">
              <button onclick="actions.showGuardians()">Show Guardians</button>
              <button onclick="actions.showGuardians(true)">Refresh</button>
            </div>
            <pre id="guardiansList" class="small muted" style="margin-top:8px;min-height:80px"></pre>
          </div>

          <div class="card">
            <h3 class="small">Set Admin Guardian</h3>
            <div class="small">Index (0..6)</div>
            <input type="text" id="guardianIdx" placeholder="index 0..6" />
            <div class="small" style="margin-top:8px">Address</div>
            <input type="text" id="guardianAddr" placeholder="0x..." />
            <div style="margin-top:8px" class="row">
              <button onclick="actions.setAdminGuardian()">Set Admin Guardian</button>
              <div id="guardianResult" class="small muted"></div>
            </div>
          </div>

          <div class="card">
            <h3 class="small">Admin Recovery (guardian flows)</h3>
            <div class="small">Propose new admin</div>
            <input type="text" id="proposeAdminAddr" placeholder="0x..." />
            <div style="margin-top:8px" class="row">
              <button onclick="actions.proposeAdminRecovery()">Propose Recovery</button>
              <button onclick="actions.approveAdminRecovery()">Approve</button>
              <button onclick="actions.executeAdminRecovery()">Execute</button>
              <div id="recoveryResult" class="small muted"></div>
            </div>
          </div>

          <div class="card">
            <h3 class="small">Deployer Guardians & Recovery</h3>
            <div class="small">Set deployer guardian (index 0..6)</div>
            <input type="text" id="deployerGuardianIdx" placeholder="index 0..6" />
            <input type="text" id="deployerGuardianAddr" placeholder="0x..." style="margin-top:8px"/>
            <div style="margin-top:8px" class="row">
              <button onclick="actions.setDeployerGuardian()">Set Deployer Guardian</button>
              <div id="deployerGuardianResult" class="small muted"></div>
            </div>

            <div style="margin-top:12px" class="small">Deployer recovery</div>
            <input type="text" id="proposeDeployerAddr" placeholder="0x..." />
            <div style="margin-top:8px" class="row">
              <button onclick="actions.proposeDeployerRecovery()">Propose</button>
              <button onclick="actions.approveDeployerRecovery()">Approve</button>
              <button onclick="actions.executeDeployerRecovery()">Execute</button>
              <div id="deployerRecoveryResult" class="small muted"></div>
            </div>
          </div>

        </section>

        <!-- Contract / ABI viewer -->
        <section id="contract" class="tab" style="display:none">
          <h1>Embedded ABI & Contract</h1>
          <div class="card">
            <div class="small">Contract address used by DApp</div>
            <input type="text" id="contractAddressInput" placeholder="0x..." />
            <div style="margin-top:8px" class="row">
              <button id="setContractBtn">Set Contract Address</button>
              <button id="reloadAbiBtn">Reload ABI</button>
              <div id="contractSetResult" class="small muted"></div>
            </div>
            <div style="margin-top:12px" class="small muted">ABI (loaded from <code>abi/CatalystNFTStakingUpgradeable.json</code>)</div>
            <pre id="abiBlock" class="mutedBlock" style="margin-top:8px;max-height:320px;overflow:auto"></pre>
          </div>
        </section>

        <!-- Whitepaper -->
        <section id="whitepaper" class="tab" style="display:none">
          <h1>Whitepaper (excerpt)</h1>
          <div class="card">
            <textarea readonly>
Catalyst Whitepaper — Universal Utility & Governance for All NFTs

Tokenomics (CATA): Deflationary mechanics: Harvest burn fee, Unstake burn fee, Registration fees; Immutable distribution: 90% Burn, 9% Treasury, 1% Deployer.

Governance: Burn-Weighted Collection Governance (BWCG): Top collections by burned CATA get full voting rights. Per-collection vote cap prevents monopolies.
            </textarea>
          </div>
        </section>

      </div>
    </main>
  </div>

  <script>
    // ---------- CONFIG ----------
    let contractAddress = "0xF6f4B2eb6b9D4e87fA5D38DE9124Dd4C212a61FD"; // default — you can change via UI
    const ABI_URL = "abi/CatalystNFTStakingUpgradeable.json"; // ensure this file exists on your server
    let provider, signer, contract, CONTRACT_ABI;

    // ---------- HELPERS ----------
    function q(id){ return document.getElementById(id); }
    function bnToStr(v){
      try {
        if (v === null || v === undefined) return "-";
        // If ethers BigInt-like or BigNumber: convert to string
        return typeof v.toString === 'function' ? v.toString() : String(v);
      } catch(e){ return String(v); }
    }

    async function fetchJSON(url){
      const res = await fetch(url);
      if(!res.ok) throw new Error(`Failed to fetch ${url}: ${res.status}`);
      return await res.json();
    }

    // ---------- ABI / Contract ----------
    async function loadABIAndShow(){
      try {
        CONTRACT_ABI = await fetchJSON(ABI_URL);
        q('abiBlock').textContent = JSON.stringify(CONTRACT_ABI, null, 2);
        return CONTRACT_ABI;
      } catch (err) {
        q('abiBlock').textContent = 'Failed to load ABI: ' + (err.message || err);
        throw err;
      }
    }

    function initContractInstance(){
      if(!CONTRACT_ABI) throw new Error("ABI not loaded");
      if(!provider) provider = new ethers.BrowserProvider(window.ethereum);
      // choose signer if available
      const connected = signer ? signer : provider;
      contract = new ethers.Contract(contractAddress, CONTRACT_ABI, connected);
      console.log("Contract instance set for", contractAddress);
      return contract;
    }

    // ---------- UI ----------
    const ui = {
      showTab: (id) => {
        document.querySelectorAll('.tab').forEach(t => t.style.display = 'none');
        const s = document.getElementById(id);
        if (s) s.style.display = 'block';
      }
    };

    // ---------- READ / DASHBOARD ----------
    async function updateDashboard(){
      if(!contract) return;
      try {
        // safe/read many values in parallel where possible
        const calls = [];
        // some functions may not exist in ABI, so guard calls with try/catch
        let globalCap = '-', collectionCap = '-', regFee = '-', treasury = '-', stakingTotal='-';
        try { globalCap = bnToStr(await contract.GLOBAL_CAP()); } catch(e){}
        try { collectionCap = bnToStr(await contract.MAX_STAKE_PER_COLLECTION()); } catch(e){}
        try { regFee = bnToStr(await contract.collectionRegistrationFee()); } catch(e){}
        try { treasury = bnToStr(await contract.treasuryBalance()); } catch(e){}
        try {
          const stats = await contract.stakingStats();
          // stakingStats returns a tuple; try property or index 0
          stakingTotal = bnToStr(stats.totalAll ?? stats[0]);
        } catch(e){}
        q('globalCap').textContent = globalCap;
        q('collectionCap').textContent = collectionCap;
        q('regFee').textContent = regFee;
        q('treasury').textContent = treasury;
        q('stakedCount').textContent = stakingTotal;

        // if signer/address present, show user-specific fields
        try {
          if (signer) {
            const userAddr = await signer.getAddress();
            // balanceOf(address) exists in ABI
            try {
              const bal = await contract.balanceOf(userAddr);
              q('cataBalance').textContent = bnToStr(bal);
            } catch(e){ q('cataBalance').textContent = '-'; }

            try {
              const burned = await contract.burnedCatalystByAddress(userAddr);
              q('burnedByAddress').textContent = bnToStr(burned);
            } catch(e){ q('burnedByAddress').textContent = '-'; }
          }
        } catch(e){ console.warn(e) }

        // attempt to compute totalRegistered by scanning registeredCollections (safe limit)
        q('totalRegistered').textContent = 'loading...';
        try {
          let count = 0;
          const MAX_SCAN = 200; // safe upper bound
          for (let i=0;i<MAX_SCAN;i++){
            try {
              const addr = await contract.registeredCollections(i);
              if(!addr || addr === ethers.ZeroAddress) break;
              count++;
            } catch(e){
              // contract might revert once index out of range; break
              break;
            }
          }
          q('totalRegistered').textContent = count.toString();
        } catch(e){
          q('totalRegistered').textContent = '-';
        }

      } catch (err) {
        console.warn("updateDashboard error:", err);
      }
    }

    // ---------- ACTIONS ----------
    const actions = {
      connect: async () => {
        if (!window.ethereum) return alert('Install MetaMask or another Web3 wallet.');
        try {
          await loadABIAndShow();
        } catch(e){
          // ABI load failed — still allow connecting but warn user
          console.warn("ABI load failed:", e);
        }

        provider = new ethers.BrowserProvider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = await provider.getSigner();
        const addr = await signer.getAddress();
        q('address').textContent = addr;
        const net = await provider.getNetwork();
        q('network').textContent = net.name + ' (' + net.chainId + ')';

        // init contract (with signer) and update dashboard
        try {
          initContractInstance();
          await updateDashboard();
        } catch (err) {
          console.warn("contract init/update failed:", err);
        }
      },

      stake: async () => {
        try {
          if(!contract) initContractInstance();
          const col = q('stakeCollection').value.trim();
          const tid = Number(q('stakeTokenId').value);
          const perm = q('stakePermanent').checked;
          if(!col || isNaN(tid)) return alert('collection + tokenId required');
          q('stakeResult').textContent = 'sending...';
          const tx = await contract.stake(col, tid, perm);
          q('stakeResult').textContent = 'tx sent: ' + tx.hash;
          await tx.wait();
          q('stakeResult').textContent = 'staked — tx mined: ' + tx.hash;
          await updateDashboard();
        } catch (err) {
          console.error(err);
          q('stakeResult').textContent = err.message || String(err);
        }
      },

      batchStake: async () => {
        try {
          if(!contract) initContractInstance();
          const col = q('batchCollection').value.trim();
          const ids = q('batchTokenIds').value.split(',').map(s=>s.trim()).filter(Boolean).map(Number);
          const perm = q('batchPermanent').checked;
          if(!col || ids.length===0) return alert('collection + tokenIds required');
          q('batchResult').textContent = 'sending...';
          const tx = await contract.batchStake(col, ids, perm);
          q('batchResult').textContent = 'tx sent: ' + tx.hash;
          await tx.wait();
          q('batchResult').textContent = 'batch staked — tx mined: ' + tx.hash;
          await updateDashboard();
        } catch (err) {
          console.error(err);
          q('batchResult').textContent = err.message || String(err);
        }
      },

      enrollBluechip: async () => {
        try {
          if(!contract) initContractInstance();
          q('enrollResult').textContent = 'sending...';
          const tx = await contract.enrollBluechip();
          q('enrollResult').textContent = 'tx: ' + tx.hash;
          await tx.wait();
          q('enrollResult').textContent = 'enrolled';
        } catch (err) {
          console.error(err);
          q('enrollResult').textContent = err.message || String(err);
        }
      },

      harvestBluechip: async () => {
        try {
          if(!contract) initContractInstance();
          const col = q('blueHarvestCollection').value.trim();
          if(!col) return alert('collection required');
          q('blueHarvestResult').textContent = 'sending...';
          // ABI contains harvestBluechip(collection)
          if (typeof contract.harvestBluechip === 'function') {
            const tx = await contract.harvestBluechip(col);
            q('blueHarvestResult').textContent = 'tx: ' + tx.hash;
            await tx.wait();
            q('blueHarvestResult').textContent = 'harvested';
          } else {
            // fallback: try generic harvest (collection, tokenId) - can't predict tokenId; warn user
            q('blueHarvestResult').textContent = 'contract.harvestBluechip not found in ABI';
          }
          await updateDashboard();
        } catch (err) {
          console.error(err);
          q('blueHarvestResult').textContent = err.message || String(err);
        }
      },

      propose: async () => {
        try {
          if(!contract) initContractInstance();
          const type = Number(q('proposalType').value);
          const param = Number(q('proposalParam').value);
          const val = Number(q('proposalValue').value);
          const context = q('proposalContext').value.trim() || ethers.ZeroAddress;
          q('proposeResult').textContent = 'sending...';
          const tx = await contract.propose(type, param, val, context);
          q('proposeResult').textContent = 'tx: ' + tx.hash;
          await tx.wait();
          q('proposeResult').textContent = 'proposal created';
        } catch (err) {
          console.error(err);
          q('proposeResult').textContent = err.message || String(err);
        }
      },

      vote: async () => {
        try {
          if(!contract) initContractInstance();
          const id = q('voteId').value.trim();
          if(!id) return alert('proposal id required');
          q('voteResult').textContent = 'sending...';
          const tx = await contract.vote(id);
          q('voteResult').textContent = 'vote tx: ' + tx.hash;
          await tx.wait();
          q('voteResult').textContent = 'voted';
        } catch (err) {
          console.error(err);
          q('voteResult').textContent = err.message || String(err);
        }
      },

      executeProposal: async () => {
        try {
          if(!contract) initContractInstance();
          const id = q('voteId').value.trim();
          if(!id) return alert('proposal id required');
          q('voteResult').textContent = 'sending...';
          const tx = await contract.executeProposal(id);
          q('voteResult').textContent = 'execute tx: ' + tx.hash;
          await tx.wait();
          q('voteResult').textContent = 'executed';
        } catch (err) {
          console.error(err);
          q('voteResult').textContent = err.message || String(err);
        }
      },

      // Admin guardian functions
      setAdminGuardian: async () => {
        try {
          if(!contract) initContractInstance();
          const idx = Number(q('guardianIdx').value);
          const addr = q('guardianAddr').value.trim();
          if(isNaN(idx) || !addr) return alert('index + address required');
          q('guardianResult').textContent = 'sending...';
          const tx = await contract.setAdminGuardian(idx, addr);
          q('guardianResult').textContent = 'tx: ' + tx.hash;
          await tx.wait();
          q('guardianResult').textContent = 'set';
          await actions.showGuardians();
        } catch (err) {
          console.error(err);
          q('guardianResult').textContent = err.message || String(err);
        }
      },

      proposeAdminRecovery: async () => {
        try {
          if(!contract) initContractInstance();
          const addr = q('proposeAdminAddr').value.trim();
          if(!addr) return alert('address required');
          q('recoveryResult').textContent = 'sending...';
          const tx = await contract.proposeAdminRecovery(addr);
          q('recoveryResult').textContent = 'tx: ' + tx.hash;
          await tx.wait();
          q('recoveryResult').textContent = 'proposed';
        } catch (err) {
          console.error(err);
          q('recoveryResult').textContent = err.message || String(err);
        }
      },

      approveAdminRecovery: async () => {
        try {
          if(!contract) initContractInstance();
          q('recoveryResult').textContent = 'sending...';
          const tx = await contract.approveAdminRecovery();
          q('recoveryResult').textContent = 'tx: ' + tx.hash;
          await tx.wait();
          q('recoveryResult').textContent = 'approved';
        } catch (err) {
          console.error(err);
          q('recoveryResult').textContent = err.message || String(err);
        }
      },

      executeAdminRecovery: async () => {
        try {
          if(!contract) initContractInstance();
          q('recoveryResult').textContent = 'sending...';
          const tx = await contract.executeAdminRecovery();
          q('recoveryResult').textContent = 'tx: ' + tx.hash;
          await tx.wait();
          q('recoveryResult').textContent = 'executed';
        } catch (err) {
          console.error(err);
          q('recoveryResult').textContent = err.message || String(err);
        }
      },

      setDeployerGuardian: async () => {
        try {
          if(!contract) initContractInstance();
          const idx = Number(q('deployerGuardianIdx').value);
          const addr = q('deployerGuardianAddr').value.trim();
          if(isNaN(idx) || !addr) return alert('index + address required');
          q('deployerGuardianResult').textContent = 'sending...';
          const tx = await contract.setDeployerGuardian(idx, addr);
          q('deployerGuardianResult').textContent = 'tx: ' + tx.hash;
          await tx.wait();
          q('deployerGuardianResult').textContent = 'set';
          await actions.showGuardians();
        } catch (err) {
          console.error(err);
          q('deployerGuardianResult').textContent = err.message || String(err);
        }
      },

      proposeDeployerRecovery: async () => {
        try {
          if(!contract) initContractInstance();
          const addr = q('proposeDeployerAddr').value.trim();
          if(!addr) return alert('address required');
          q('deployerRecoveryResult').textContent = 'sending...';
          const tx = await contract.proposeDeployerRecovery(addr);
          q('deployerRecoveryResult').textContent = 'tx: ' + tx.hash;
          await tx.wait();
          q('deployerRecoveryResult').textContent = 'proposed';
        } catch (err) {
          console.error(err);
          q('deployerRecoveryResult').textContent = err.message || String(err);
        }
      },

      approveDeployerRecovery: async () => {
        try {
          if(!contract) initContractInstance();
          q('deployerRecoveryResult').textContent = 'sending...';
          const tx = await contract.approveDeployerRecovery();
          q('deployerRecoveryResult').textContent = 'tx: ' + tx.hash;
          await tx.wait();
          q('deployerRecoveryResult').textContent = 'approved';
        } catch (err) {
          console.error(err);
          q('deployerRecoveryResult').textContent = err.message || String(err);
        }
      },

      executeDeployerRecovery: async () => {
        try {
          if(!contract) initContractInstance();
          q('deployerRecoveryResult').textContent = 'sending...';
          const tx = await contract.executeDeployerRecovery();
          q('deployerRecoveryResult').textContent = 'tx: ' + tx.hash;
          await tx.wait();
          q('deployerRecoveryResult').textContent = 'executed';
        } catch (err) {
          console.error(err);
          q('deployerRecoveryResult').textContent = err.message || String(err);
        }
      },

      // reads and prints both deployerGuardians (0..6) and adminGuardians (0..6)
      showGuardians: async (force=false) => {
        try {
          if(!CONTRACT_ABI) await loadABIAndShow();
          if(!contract) initContractInstance();
          q('guardiansList').textContent = 'loading guardians...';
          const lines = [];
          // deployerGuardians
          lines.push('--- Deployer Guardians ---');
          for(let i=0;i<7;i++){
            try {
              const g = await contract.deployerGuardians(i);
              lines.push(`deployer[${i}]: ${g === ethers.ZeroAddress ? '(zero address)' : g}`);
            } catch(e){
              lines.push(`deployer[${i}]: (error / not available)`);
            }
          }
          // adminGuardians
          lines.push('--- Admin Guardians ---');
          for(let i=0;i<7;i++){
            try {
              const g = await contract.adminGuardians(i);
              lines.push(`admin[${i}]: ${g === ethers.ZeroAddress ? '(zero address)' : g}`);
            } catch(e){
              lines.push(`admin[${i}]: (error / not available)`);
            }
          }
          q('guardiansList').textContent = lines.join('\n');
        } catch (err) {
          q('guardiansList').textContent = 'failed: ' + (err.message || String(err));
        }
      }
    };

    // ---------- UI hooks ----------
    document.getElementById('connectBtn').addEventListener('click', actions.connect);

    // contract tab controls
    document.getElementById('reloadAbiBtn').addEventListener('click', async ()=>{
      try { await loadABIAndShow(); q('contractSetResult').textContent = 'ABI reloaded'; } catch(e){ q('contractSetResult').textContent = 'ABI load failed'; }
    });
    document.getElementById('setContractBtn').addEventListener('click', ()=>{
      const input = q('contractAddressInput').value.trim();
      if(!input) return alert('enter a contract address');
      contractAddress = input;
      try {
        if(CONTRACT_ABI) initContractInstance();
        q('contractSetResult').textContent = 'contract set: ' + contractAddress;
        updateDashboard();
      } catch (e){
        q('contractSetResult').textContent = 'set, but instance init failed: ' + (e.message||e);
      }
    });

    // set initial input values
    q('contractAddressInput').value = contractAddress;

    // show initial tab
    ui.showTab('overview');

    // Try to preload ABI (non-blocking)
    loadABIAndShow().catch(e => console.warn('Initial ABI load failed', e));

    // WALLET / CHAIN change handling (optional): update on accounts/chain change
    if (window.ethereum) {
      window.ethereum.on && window.ethereum.on('accountsChanged', async ()=> {
        try {
          provider = new ethers.BrowserProvider(window.ethereum);
          signer = await provider.getSigner();
          q('address').textContent = await signer.getAddress();
          if(contract) initContractInstance();
          await updateDashboard();
        } catch(e){ console.warn(e) }
      });
      window.ethereum.on && window.ethereum.on('chainChanged', async ()=> {
        try {
          provider = new ethers.BrowserProvider(window.ethereum);
          const net = await provider.getNetwork();
          q('network').textContent = net.name + ' (' + net.chainId + ')';
          if(contract) initContractInstance();
          await updateDashboard();
        } catch(e){ console.warn(e) }
      });
    }
  </script>
</body>
</html>
