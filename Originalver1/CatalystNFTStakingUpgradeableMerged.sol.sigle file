// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/*
  CatalystNFTStakingUpgradeableMerged.sol

  Single-file merge of:
    - Main contract
    - Staking logic (inlined)
    - Governance logic (inlined, simplified)
    - Bluechip logic (inlined)
    - Guardian recovery logic (inlined)

  Notes:
    - Compact custom errors used to reduce bytecode.
    - Keep OpenZeppelin upgradeable imports (standard).
    - Requires thorough testing + audit before production.
*/

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/utils/introspection/IERC165.sol";

/* ========== Compact Custom Errors ========== */
error ZeroAddress();
error BadParam();
error NotRegistered();
error AlreadyExists();
error NotStaked();
error TermNotExpired();
error Cooldown();
error BatchTooLarge();
error Ineligible();
error Unauthorized();
error NoRequest();
error Expired();
error AlreadyApproved();
error Threshold();
error Insufficient();
error NotERC721Sender();
error Throttled();

/* ========== Contract ========== */
contract CatalystNFTStakingUpgradeable is
    Initializable,
    UUPSUpgradeable,
    ERC20Upgradeable,
    AccessControlUpgradeable,
    ReentrancyGuardUpgradeable,
    PausableUpgradeable
{
    /* ======== Roles ======== */
    bytes32 public constant CONTRACT_ADMIN_ROLE = keccak256("CONTRACT_ADMIN_ROLE");

    /* ======== Economic Constants (immutable semantics) ======== */
    uint256 public constant BURN_BP = 9000;    // 90%
    uint256 public constant TREASURY_BP = 900; // 9%
    uint256 public constant DEPLOYER_BP = 100; // 1%
    uint256 public constant BP_DENOM = 10000;

    /* ======== Caps & Limits ======== */
    uint256 public constant GLOBAL_CAP = 1_000_000_000;
    uint256 public constant TERM_CAP   = 750_000_000;
    uint256 public constant PERM_CAP   = 250_000_000;
    uint256 public constant MAX_HARVEST_BATCH = 50;
    uint256 public constant MAX_STAKE_PER_COLLECTION = 20_000;
    uint256 public constant WEIGHT_SCALE = 1e18;

    /* ======== Guardian constants (7-of-5 style) ======== */
    uint8  public constant DEPLOYER_GCOUNT = 7;
    uint8  public constant DEPLOYER_THRESHOLD = 5;
    uint8  public constant ADMIN_GCOUNT = 7;
    uint8  public constant ADMIN_THRESHOLD = 5;
    uint256 public constant RECOVERY_WINDOW = 3 days;

    /* ================= Storage ================= */

    // Protocol params
    uint256 public numberOfBlocksPerRewardUnit;
    uint256 public termDurationBlocks;
    uint256 public stakingCooldownBlocks;
    uint256 public rewardRateIncrementPerNFT;
    uint256 public initialHarvestBurnFeeRate; // 0..100 (percentage)
    uint256 public unstakeBurnFee;           // flat CATA

    uint256 public collectionRegistrationFee;

    // treasury + deployer
    address public treasuryAddress;
    address public deployerAddress;
    uint256 public treasuryBalance;

    // governance helpers
    uint256 public minStakeAgeForVoting;
    uint256 public maxBaseRewardRate;

    // Registered collections enumeration
    address[] public registeredCollections;
    mapping(address => uint256) public registeredIndex; // index+1 (0 == not registered)

    // Burn bookkeeping
    mapping(address => uint256) public burnedCatalystByAddress;

    // Staking cooldown per user
    mapping(address => uint256) public lastStakingBlock;

    /* ======== Staking storage (inlined lib) ======== */
    struct StakeInfo {
        address owner;
        uint256 tokenId;
        bool currentlyStaked;
        bool isPermanent;
        uint256 stakeBlock;
        uint256 unstakeDeadlineBlock; // for term stake
        uint256 rewardRateSnapshot;   // store reward increment snapshot for bookkeeping
        uint256 lastHarvestBlock;
    }

    // collection => owner => tokenId => StakeInfo
    mapping(address => mapping(address => mapping(uint256 => StakeInfo))) public stakeLog;

    // collection => owner => list of tokenIds (portfolio)
    mapping(address => mapping(address => uint256[])) public stakePortfolioByUser;

    // collection-level totals
    mapping(address => uint256) public collectionTotalStaked;
    uint256 public totalStakedAll;
    uint256 public totalStakedTerm;
    uint256 public totalStakedPermanent;
    uint256 public baseRewardRate; // base rate used by staking lib

    /* ======== Blue-chip storage (inlined lib) ======== */
    mapping(address => bool) public isBluechipCollection;
    // per-collection per-wallet enrollment info
    struct WalletEnrollment {
        bool enrolled;
        uint256 enrolledAtBlock;
    }
    // bluechipWallets[collection][wallet]
    mapping(address => mapping(address => WalletEnrollment)) public bluechipWallets;

    uint256 public bluechipWalletFee; // per-wallet fee (Option A)

    /* ======== Governance storage (inlined lib, simplified) ======== */
    enum ProposalType { BASE_REWARD, HARVEST_FEE, UNSTAKE_FEE, REGISTRATION_FEE_FALLBACK, VOTING_PARAM, TIER_UPGRADE }

    struct Proposal {
        ProposalType pType;
        uint8 paramTarget;
        uint256 newValue;
        address collectionContext;
        address proposer;
        uint256 startBlock;
        uint256 endBlock;
        uint256 forWeight;
        uint256 againstWeight;
        bool executed;
    }

    // id => proposal
    mapping(bytes32 => Proposal) public proposals;
    // simple existence mapping
    mapping(bytes32 => bool) public proposalExists;
    // votes: proposalId => voter => bool (prevent double-vote)
    mapping(bytes32 => mapping(address => bool)) public proposalVoted;

    // governance meta
    uint256 public votingDurationBlocks;
    uint256 public minVotesRequiredScaled; // scaled value for minimum votes across collections
    uint256 public collectionVoteCapPercent;

    // proposer throttle
    mapping(address => uint256) public lastProposalBlock;

    /* ======== Guardian storage (inlined) ======== */
    address[DEPLOYER_GCOUNT] public deployerGuardians;
    mapping(address => bool) public isDeployerGuardian;
    address[ADMIN_GCOUNT] public adminGuardians;
    mapping(address => bool) public isAdminGuardian;

    struct RecoveryRequest {
        address proposed;
        uint8 approvals;
        uint256 deadline;
        bool executed;
    }
    RecoveryRequest public deployerRecovery;
    mapping(address => bool) public deployerHasApproved;

    RecoveryRequest public adminRecovery;
    mapping(address => bool) public adminHasApproved;

    /* ================= Events ================= */
    event CollectionAdded(address indexed collection, uint256 declaredSupply, uint256 paid);
    event NFTStaked(address indexed owner, address indexed collection, uint256 indexed tokenId, bool permanent);
    event NFTUnstaked(address indexed owner, address indexed collection, uint256 indexed tokenId);
    event RewardsHarvested(address indexed owner, address indexed collection, uint256 gross, uint256 burned);
    event TreasuryDeposit(address indexed from, uint256 amount);
    event TreasuryWithdrawal(address indexed to, uint256 amount);

    event BluechipEnrolled(address indexed wallet);
    event BluechipHarvested(address indexed wallet, address indexed collection, uint256 reward);

    event ProposalCreated(bytes32 id, address proposer, ProposalType pType, uint256 newValue);
    event Voted(bytes32 id, address voter, bool support, uint256 weight);
    event ProposalExecuted(bytes32 id, uint256 appliedValue);

    event GuardianSet(bytes32 council, uint8 idx, address guardian);
    event DeployerRecoveryProposed(address indexed proposer, address proposed, uint256 deadline);
    event DeployerRecoveryApproved(address indexed guardian, uint8 approvals);
    event DeployerRecovered(address indexed oldDeployer, address indexed newDeployer);
    event AdminRecoveryProposed(address indexed proposer, address proposed, uint256 deadline);
    event AdminRecoveryApproved(address indexed guardian, uint8 approvals);
    event AdminRecovered(address indexed newAdmin);

    /* ================= Modifiers / Guards ================= */
    modifier onlyRegistered(address collection) {
        if (registeredIndex[collection] == 0) revert NotRegistered();
        _;
    }

    modifier notInCooldown() {
        if (stakingCooldownBlocks > 0 && block.number < lastStakingBlock[msg.sender] + stakingCooldownBlocks) revert Cooldown();
        _;
    }

    /* ================= Initializer ================= */
    struct InitConfig {
        address owner;
        uint256 rewardRateIncrementPerNFT;
        uint256 initialHarvestBurnFeeRate;
        uint256 unstakeBurnFee;
        uint256 termDurationBlocks;
        uint256 numberOfBlocksPerRewardUnit;
        uint256 collectionRegistrationFee;
        uint256 stakingCooldownBlocks;
        uint256 votingDurationBlocks;
        uint256 minVotesRequiredScaled;
        uint256 collectionVoteCapPercent;
        uint256 minStakeAgeForVoting;
        uint256 maxBaseRewardRate;
        address[DEPLOYER_GCOUNT] deployerGuardians;
        address[ADMIN_GCOUNT] adminGuardians;
        uint256 bluechipWalletFee;
    }

    function initialize(InitConfig calldata cfg) external initializer {
        if (cfg.owner == address(0)) revert ZeroAddress();

        __ERC20_init("Catalyst", "CATA");
        __AccessControl_init();
        __UUPSUpgradeable_init();
        __ReentrancyGuard_init();
        __Pausable_init();

        _grantRole(DEFAULT_ADMIN_ROLE, cfg.owner);
        _grantRole(CONTRACT_ADMIN_ROLE, cfg.owner);

        deployerAddress = cfg.owner;
        treasuryAddress = address(this);

        rewardRateIncrementPerNFT = cfg.rewardRateIncrementPerNFT;
        initialHarvestBurnFeeRate = cfg.initialHarvestBurnFeeRate;
        unstakeBurnFee = cfg.unstakeBurnFee;
        termDurationBlocks = cfg.termDurationBlocks;
        numberOfBlocksPerRewardUnit = cfg.numberOfBlocksPerRewardUnit;
        collectionRegistrationFee = cfg.collectionRegistrationFee;
        stakingCooldownBlocks = cfg.stakingCooldownBlocks;

        votingDurationBlocks = cfg.votingDurationBlocks;
        minVotesRequiredScaled = cfg.minVotesRequiredScaled;
        collectionVoteCapPercent = cfg.collectionVoteCapPercent;
        minStakeAgeForVoting = cfg.minStakeAgeForVoting;
        maxBaseRewardRate = cfg.maxBaseRewardRate == 0 ? type(uint256).max : cfg.maxBaseRewardRate;

        // seed guardians (strong guard: zero not allowed)
        for (uint8 i = 0; i < DEPLOYER_GCOUNT; ++i) {
            address a = cfg.deployerGuardians[i];
            if (a == address(0)) revert ZeroAddress();
            if (isDeployerGuardian[a]) revert AlreadyExists();
            deployerGuardians[i] = a;
            isDeployerGuardian[a] = true;
            emit GuardianSet(keccak256("DEPLOYER"), i, a);
        }
        for (uint8 j = 0; j < ADMIN_GCOUNT; ++j) {
            address a = cfg.adminGuardians[j];
            if (a == address(0)) revert ZeroAddress();
            if (isAdminGuardian[a]) revert AlreadyExists();
            adminGuardians[j] = a;
            isAdminGuardian[a] = true;
            emit GuardianSet(keccak256("ADMIN"), j, a);
        }

        bluechipWalletFee = cfg.bluechipWalletFee;

        // optional genesis mint
        _mint(cfg.owner, 100_000_000 * 1e18);
    }

    /* ============================ Guardians (7:5 flows) ============================ */

    // Admin only setters for guardian slots (strong: no zero)
    function setDeployerGuardian(uint8 idx, address guardian) external onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {
        if (idx >= DEPLOYER_GCOUNT) revert BadParam();
        if (guardian == address(0)) revert ZeroAddress();
        address old = deployerGuardians[idx];
        if (old != address(0)) isDeployerGuardian[old] = false;
        if (isDeployerGuardian[guardian]) revert AlreadyExists();
        deployerGuardians[idx] = guardian;
        isDeployerGuardian[guardian] = true;
        emit GuardianSet(keccak256("DEPLOYER"), idx, guardian);
    }

    function setAdminGuardian(uint8 idx, address guardian) external onlyRole(DEFAULT_ADMIN_ROLE) whenNotPaused {
        if (idx >= ADMIN_GCOUNT) revert BadParam();
        if (guardian == address(0)) revert ZeroAddress();
        address old = adminGuardians[idx];
        if (old != address(0)) isAdminGuardian[old] = false;
        if (isAdminGuardian[guardian]) revert AlreadyExists();
        adminGuardians[idx] = guardian;
        isAdminGuardian[guardian] = true;
        emit GuardianSet(keccak256("ADMIN"), idx, guardian);
    }

    // Deployer recovery
    function proposeDeployerRecovery(address newDeployer) external whenNotPaused {
        if (!isDeployerGuardian[msg.sender]) revert Unauthorized();
        if (newDeployer == address(0)) revert ZeroAddress();

        deployerRecovery.proposed = newDeployer;
        deployerRecovery.approvals = 0;
        deployerRecovery.deadline = block.timestamp + RECOVERY_WINDOW;
        deployerRecovery.executed = false;

        // clear approvals
        for (uint8 i = 0; i < DEPLOYER_GCOUNT; ++i) {
            address gaddr = deployerGuardians[i];
            if (gaddr != address(0)) deployerHasApproved[gaddr] = false;
        }
        emit DeployerRecoveryProposed(msg.sender, newDeployer, deployerRecovery.deadline);
    }

    function approveDeployerRecovery() external whenNotPaused {
        if (!isDeployerGuardian[msg.sender]) revert Unauthorized();
        if (deployerRecovery.proposed == address(0)) revert NoRequest();
        if (block.timestamp > deployerRecovery.deadline) revert Expired();
        if (deployerRecovery.executed) revert AlreadyApproved();
        if (deployerHasApproved[msg.sender]) revert AlreadyApproved();

        deployerHasApproved[msg.sender] = true;
        deployerRecovery.approvals += 1;
        emit DeployerRecoveryApproved(msg.sender, deployerRecovery.approvals);
    }

    function executeDeployerRecovery() external whenNotPaused {
        if (deployerRecovery.proposed == address(0)) revert NoRequest();
        if (block.timestamp > deployerRecovery.deadline) revert Expired();
        if (deployerRecovery.executed) revert AlreadyApproved();
        if (deployerRecovery.approvals < DEPLOYER_THRESHOLD) revert Threshold();

        address old = deployerAddress;
        deployerAddress = deployerRecovery.proposed;
        deployerRecovery.executed = true;

        // optionally remove old from deployer guardians if present (defensive)
        if (isDeployerGuardian[old]) {
            for (uint8 i = 0; i < DEPLOYER_GCOUNT; ++i) {
                if (deployerGuardians[i] == old) {
                    isDeployerGuardian[old] = false;
                    deployerGuardians[i] = address(0);
                    emit GuardianSet(keccak256("DEPLOYER"), i, address(0));
                    break;
                }
            }
        }
        emit DeployerRecovered(old, deployerAddress);
    }

    // Admin recovery
    function proposeAdminRecovery(address newAdmin) external whenNotPaused {
        if (!isAdminGuardian[msg.sender]) revert Unauthorized();
        if (newAdmin == address(0)) revert ZeroAddress();

        adminRecovery.proposed = newAdmin;
        adminRecovery.approvals = 0;
        adminRecovery.deadline = block.timestamp + RECOVERY_WINDOW;
        adminRecovery.executed = false;

        for (uint8 i = 0; i < ADMIN_GCOUNT; ++i) {
            address gaddr = adminGuardians[i];
            if (gaddr != address(0)) adminHasApproved[gaddr] = false;
        }
        emit AdminRecoveryProposed(msg.sender, newAdmin, adminRecovery.deadline);
    }

    function approveAdminRecovery() external whenNotPaused {
        if (!isAdminGuardian[msg.sender]) revert Unauthorized();
        if (adminRecovery.proposed == address(0)) revert NoRequest();
        if (block.timestamp > adminRecovery.deadline) revert Expired();
        if (adminRecovery.executed) revert AlreadyApproved();
        if (adminHasApproved[msg.sender]) revert AlreadyApproved();

        adminHasApproved[msg.sender] = true;
        adminRecovery.approvals += 1;
        emit AdminRecoveryApproved(msg.sender, adminRecovery.approvals);
    }

    function executeAdminRecovery() external whenNotPaused {
        if (adminRecovery.proposed == address(0)) revert NoRequest();
        if (block.timestamp > adminRecovery.deadline) revert Expired();
        if (adminRecovery.executed) revert AlreadyApproved();
        if (adminRecovery.approvals < ADMIN_THRESHOLD) revert Threshold();

        _grantRole(DEFAULT_ADMIN_ROLE, adminRecovery.proposed);
        adminRecovery.executed = true;
        emit AdminRecovered(adminRecovery.proposed);
    }

    /* ============================ Registration ============================ */

    function registerCollection(address collection, uint256 declaredMaxSupply)
        external
        whenNotPaused
        nonReentrant
    {
        if (collection == address(0)) revert ZeroAddress();
        if (registeredIndex[collection] != 0) revert AlreadyExists();
        if (declaredMaxSupply == 0 || declaredMaxSupply > MAX_STAKE_PER_COLLECTION) revert BadParam();

        // basic sanity: ensure collection is ERC721 (via ERC165)
        try IERC165(collection).supportsInterface(type(IERC721).interfaceId) returns (bool ok) {
            if (!ok) revert BadParam();
        } catch {
            revert BadParam();
        }

        if (collectionRegistrationFee > 0) _splitFeeFromSender(msg.sender, collectionRegistrationFee);

        // initialize collection totals (implicitly via mapping; nothing else needed)
        registeredCollections.push(collection);
        registeredIndex[collection] = registeredCollections.length; // 1-based
        emit CollectionAdded(collection, declaredMaxSupply, collectionRegistrationFee);
    }

    /* ============================ Staking (custodial) ============================ */

    function stake(address collection, uint256 tokenId, bool permanent)
        public
        whenNotPaused
        nonReentrant
        notInCooldown
    {
        if (collection == address(0)) revert ZeroAddress();
        if (registeredIndex[collection] == 0) revert NotRegistered();

        // transfer NFT into contract (custodial)
        IERC721(collection).safeTransferFrom(msg.sender, address(this), tokenId);

        StakeInfo storage si = stakeLog[collection][msg.sender][tokenId];
        if (si.currentlyStaked) revert AlreadyExists();

        si.owner = msg.sender;
        si.tokenId = tokenId;
        si.currentlyStaked = true;
        si.isPermanent = permanent;
        si.stakeBlock = block.number;
        si.lastHarvestBlock = block.number;
        si.rewardRateSnapshot = rewardRateIncrementPerNFT;

        if (permanent) {
            totalStakedPermanent += 1;
            totalStakedAll += 1;
        } else {
            totalStakedTerm += 1;
            totalStakedAll += 1;
            si.unstakeDeadlineBlock = block.number + termDurationBlocks;
        }

        collectionTotalStaked[collection] += 1;
        stakePortfolioByUser[collection][msg.sender].push(tokenId);
        lastStakingBlock[msg.sender] = block.number;

        emit NFTStaked(msg.sender, collection, tokenId, permanent);
    }

    function batchStake(address collection, uint256[] calldata tokenIds, bool permanent)
        external
        whenNotPaused
        nonReentrant
        notInCooldown
    {
        uint256 n = tokenIds.length;
        if (n == 0 || n > MAX_HARVEST_BATCH) revert BatchTooLarge();
        for (uint256 i = 0; i < n; ++i) stake(collection, tokenIds[i], permanent);
    }

    function _pendingRewardInternal(address collection, address owner, uint256 tokenId) internal view returns (uint256) {
        StakeInfo storage si = stakeLog[collection][owner][tokenId];
        if (!si.currentlyStaked) return 0;
        uint256 blocks = block.number - si.lastHarvestBlock;
        // simple model: baseRewardRate + increment * time (customize as needed)
        uint256 rate = baseRewardRate + si.rewardRateSnapshot;
        return blocks * rate / numberOfBlocksPerRewardUnit;
    }

    function pendingRewardsView(address collection, address owner, uint256 tokenId) external view returns (uint256) {
        return _pendingRewardInternal(collection, owner, tokenId);
    }

    function harvest(address collection, uint256 tokenId) external whenNotPaused nonReentrant {
        StakeInfo storage si = stakeLog[collection][msg.sender][tokenId];
        if (!si.currentlyStaked) revert NotStaked();

        uint256 reward = _pendingRewardInternal(collection, msg.sender, tokenId);
        if (reward == 0) return;

        uint256 burnAmt = (reward * initialHarvestBurnFeeRate) / 100;
        _mint(msg.sender, reward);
        if (burnAmt > 0) {
            _burn(msg.sender, burnAmt);
            burnedCatalystByAddress[msg.sender] += burnAmt;
        }
        si.lastHarvestBlock = block.number;
        emit RewardsHarvested(msg.sender, collection, reward, burnAmt);
    }

    function unstake(address collection, uint256 tokenId) external whenNotPaused nonReentrant {
        StakeInfo memory info = stakeLog[collection][msg.sender][tokenId];
        if (!info.currentlyStaked) revert NotStaked();
        if (!info.isPermanent && block.number < info.unstakeDeadlineBlock) revert TermNotExpired();

        // harvest pending
        uint256 reward = _pendingRewardInternal(collection, msg.sender, tokenId);
        if (reward > 0) {
            uint256 burnAmt = (reward * initialHarvestBurnFeeRate) / 100;
            _mint(msg.sender, reward);
            if (burnAmt > 0) {
                _burn(msg.sender, burnAmt);
                burnedCatalystByAddress[msg.sender] += burnAmt;
            }
            emit RewardsHarvested(msg.sender, collection, reward, burnAmt);
        }

        // unstake fee
        if (unstakeBurnFee > 0) {
            _splitFeeFromSender(msg.sender, unstakeBurnFee);
        }

        // remove stake
        // mark not staked
        delete stakeLog[collection][msg.sender][tokenId];

        // remove tokenId from portfolio array (gas-costly; keep simple)
        uint256[] storage arr = stakePortfolioByUser[collection][msg.sender];
        for (uint256 i = 0; i < arr.length; ++i) {
            if (arr[i] == tokenId) {
                arr[i] = arr[arr.length - 1];
                arr.pop();
                break;
            }
        }

        collectionTotalStaked[collection] -= 1;
        if (info.isPermanent) {
            totalStakedPermanent -= 1;
            totalStakedAll -= 1;
        } else {
            totalStakedTerm -= 1;
            totalStakedAll -= 1;
        }

        // transfer back NFT
        IERC721(collection).safeTransferFrom(address(this), msg.sender, tokenId);
        emit NFTUnstaked(msg.sender, collection, tokenId);
    }

    /* ============================ Blue-chip (non-custodial) ============================ */

    // Admin flags/unflags blue-chip collections
    function setBluechipCollection(address collection, bool isBluechip) external onlyRole(CONTRACT_ADMIN_ROLE) whenNotPaused {
        if (collection == address(0)) revert ZeroAddress();
        if (registeredIndex[collection] == 0) revert NotRegistered();
        isBluechipCollection[collection] = isBluechip;
    }

    // Wallet enrollment (per-wallet fee)
    function enrollBluechip() external whenNotPaused nonReentrant {
        uint256 fee = bluechipWalletFee;
        if (fee > 0) _splitFeeFromSender(msg.sender, fee);
        WalletEnrollment storage we = bluechipWallets[address(0)][msg.sender]; // use address(0) as global slot
        if (we.enrolled) revert AlreadyExists();
        we.enrolled = true;
        we.enrolledAtBlock = block.number;
        emit BluechipEnrolled(msg.sender);
    }

    // Harvest bluechip for specific collection (wallet must be enrolled and own at least 1 token)
    function harvestBluechip(address collection) external whenNotPaused nonReentrant {
        if (!isBluechipCollection[collection]) revert Ineligible();
        WalletEnrollment storage we = bluechipWallets[address(0)][msg.sender];
        if (!we.enrolled) revert Ineligible();
        if (IERC721(collection).balanceOf(msg.sender) == 0) revert Ineligible();

        // compute a simple reward: baseRewardRate for this wallet per token (example)
        uint256 reward = baseRewardRate * 1; // placeholder: implement more nuanced formula as needed
        if (reward == 0) return;

        _mint(msg.sender, reward);
        emit BluechipHarvested(msg.sender, collection, reward);
    }

    /* ============================ Governance ============================ */

    // Create proposal
    function propose(
        ProposalType pType,
        uint8 paramTarget,
        uint256 newValue,
        address collectionContext
    ) external whenNotPaused returns (bytes32) {
        // eligibility: must have voting weight
        (uint256 weight,) = _votingWeight(msg.sender);
        if (weight == 0) revert Ineligible();

        // throttle: 1 proposal per block per address
        if (lastProposalBlock[msg.sender] == block.number) revert Throttled();
        lastProposalBlock[msg.sender] = block.number;

        bytes32 id = keccak256(abi.encodePacked(msg.sender, block.number, pType, paramTarget, newValue, collectionContext));
        if (proposalExists[id]) revert AlreadyExists();

        Proposal storage p = proposals[id];
        p.pType = pType;
        p.paramTarget = paramTarget;
        p.newValue = newValue;
        p.collectionContext = collectionContext;
        p.proposer = msg.sender;
        p.startBlock = block.number;
        p.endBlock = block.number + votingDurationBlocks;
        p.forWeight = 0;
        p.againstWeight = 0;
        p.executed = false;

        proposalExists[id] = true;
        emit ProposalCreated(id, msg.sender, pType, newValue);
        return id;
    }

    // Vote (support = true => for)
    function vote(bytes32 id, bool support) external whenNotPaused {
        if (!proposalExists[id]) revert NoRequest();
        Proposal storage p = proposals[id];
        if (block.number < p.startBlock) revert BadParam();
        if (block.number > p.endBlock) revert Expired();
        if (proposalVoted[id][msg.sender]) revert AlreadyApproved();

        (uint256 weight, ) = _votingWeight(msg.sender);
        if (weight == 0) revert Ineligible();

        proposalVoted[id][msg.sender] = true;
        if (support) p.forWeight += weight; else p.againstWeight += weight;
        emit Voted(id, msg.sender, support, weight);
    }

    // Execute proposal (anyone)
    function executeProposal(bytes32 id) external whenNotPaused nonReentrant {
        if (!proposalExists[id]) revert NoRequest();
        Proposal storage p = proposals[id];
        if (block.number <= p.endBlock) revert Expired();
        if (p.executed) revert AlreadyApproved();

        uint256 totalVotes = p.forWeight + p.againstWeight;
        if (totalVotes < minVotesRequiredScaled) revert Threshold();

        // enforce collection caps, burn-weighted concerns and other validations are assumed done off-chain or via smart rules here
        // apply the change
        if (p.pType == ProposalType.BASE_REWARD) {
            uint256 old = baseRewardRate;
            baseRewardRate = p.newValue > maxBaseRewardRate ? maxBaseRewardRate : p.newValue;
            emit BaseRewardRateUpdated(old, baseRewardRate);
        } else if (p.pType == ProposalType.HARVEST_FEE) {
            uint256 old = initialHarvestBurnFeeRate;
            initialHarvestBurnFeeRate = p.newValue; // assume 0..100
            emit HarvestFeeUpdated(old, p.newValue);
        } else if (p.pType == ProposalType.UNSTAKE_FEE) {
            uint256 old = unstakeBurnFee;
            unstakeBurnFee = p.newValue;
            emit UnstakeFeeUpdated(old, p.newValue);
        } else if (p.pType == ProposalType.REGISTRATION_FEE_FALLBACK) {
            uint256 old = collectionRegistrationFee;
            collectionRegistrationFee = p.newValue;
            emit RegistrationFeeUpdated(old, p.newValue);
        } else if (p.pType == ProposalType.VOTING_PARAM) {
            uint8 t = p.paramTarget;
            if (t == 0) {
                uint256 old = minVotesRequiredScaled;
                minVotesRequiredScaled = p.newValue;
                emit VotingParamUpdated(t, old, p.newValue);
            } else if (t == 1) {
                uint256 old = votingDurationBlocks;
                votingDurationBlocks = p.newValue;
                emit VotingParamUpdated(t, old, p.newValue);
            } else if (t == 2) {
                uint256 old = collectionVoteCapPercent;
                collectionVoteCapPercent = p.newValue;
                emit VotingParamUpdated(t, old, p.newValue);
            } else revert BadParam();
        } else if (p.pType == ProposalType.TIER_UPGRADE) {
            // Hooks for future upgrades (not implemented here)
        } else {
            revert BadParam();
        }

        p.executed = true;
        emit ProposalExecuted(id, p.newValue);
    }

    // compute simplified voting weight
    function _votingWeight(address voter) internal view returns (uint256 weight, address attributedCollection) {
        // 1) check custodial stakes older than minStakeAgeForVoting
        for (uint256 i = 0; i < registeredCollections.length; ++i) {
            address coll = registeredCollections[i];
            uint256[] storage port = stakePortfolioByUser[coll][voter];
            if (port.length == 0) continue;
            for (uint256 j = 0; j < port.length; ++j) {
                StakeInfo storage si = stakeLog[coll][voter][port[j]];
                if (si.currentlyStaked && block.number >= si.stakeBlock + minStakeAgeForVoting) {
                    return (WEIGHT_SCALE, coll);
                }
            }
        }

        // 2) enrolled blue-chip + own at least one token
        WalletEnrollment storage we = bluechipWallets[address(0)][voter];
        if (we.enrolled) {
            for (uint256 i = 0; i < registeredCollections.length; ++i) {
                address coll = registeredCollections[i];
                if (isBluechipCollection[coll] && IERC721(coll).balanceOf(voter) > 0) {
                    return (WEIGHT_SCALE, coll);
                }
            }
        }

        return (0, address(0));
    }

    /* ============================ Fees / Treasury ============================ */
    function _splitFeeFromSender(address payer, uint256 amount) internal {
        if (amount == 0) return;
        if (balanceOf(payer) < amount) revert Insufficient();

        uint256 burnAmt = (amount * BURN_BP) / BP_DENOM;
        uint256 treasuryAmt = (amount * TREASURY_BP) / BP_DENOM;
        uint256 deployerAmt = amount - burnAmt - treasuryAmt;

        if (burnAmt > 0) _burn(payer, burnAmt);
        if (treasuryAmt > 0) {
            _transfer(payer, address(this), treasuryAmt);
            treasuryBalance += treasuryAmt;
            emit TreasuryDeposit(payer, treasuryAmt);
        }
        if (deployerAmt > 0) _transfer(payer, deployerAddress, deployerAmt);
    }

    function withdrawTreasury(address to, uint256 amount) external onlyRole(CONTRACT_ADMIN_ROLE) whenNotPaused nonReentrant {
        if (to == address(0)) revert ZeroAddress();
        if (amount > treasuryBalance) revert Insufficient();
        treasuryBalance -= amount;
        _transfer(address(this), to, amount);
        emit TreasuryWithdrawal(to, amount);
    }

    /* ============================ Views ============================ */

    function stakingStats() external view returns (
        uint256 totalAll,
        uint256 totalTerm,
        uint256 totalPermanent,
        uint256 remainingGlobal,
        uint256 remainingTerm,
        uint256 remainingPermanent
    ) {
        totalAll = totalStakedAll;
        totalTerm = totalStakedTerm;
        totalPermanent = totalStakedPermanent;
        remainingGlobal = GLOBAL_CAP > totalAll ? GLOBAL_CAP - totalAll : 0;
        remainingTerm = TERM_CAP > totalTerm ? TERM_CAP - totalTerm : 0;
        remainingPermanent = PERM_CAP > totalPermanent ? PERM_CAP - totalPermanent : 0;
    }

    function collectionCount() external view returns (uint256) {
        return registeredCollections.length;
    }

    /* ============================ ERC721 Receiver, Pause, Upgrade ============================ */

    // Accept ERC721 tokens only from registered collection transfers into this contract when staking.
    function onERC721Received(address, address, uint256, bytes calldata) external view returns (bytes4) {
        // In some flows we accept NFTs transferred; require that msg.sender is registered
        if (registeredIndex[msg.sender] == 0) revert NotERC721Sender();
        return this.onERC721Received.selector;
    }

    function pause() external onlyRole(CONTRACT_ADMIN_ROLE) {
        _pause();
    }

    function unpause() external onlyRole(CONTRACT_ADMIN_ROLE) {
        _unpause();
    }

    function _authorizeUpgrade(address) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}

    // gap for upgradeable contract
    uint256[50] private __gap;
}
