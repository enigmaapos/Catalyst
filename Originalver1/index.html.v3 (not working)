<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Catalyst DApp — Detailed Dashboard v3</title>

<!-- Ethers v6 (UMD) -->
<script src="https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.umd.min.js"></script>

<style>
  :root { --bg:#0f1220; --card:#171a2b; --muted:#9aa3b2; --text:#e7ecf4; --acc:#6ee7ff; }
  * { box-sizing:border-box; }
  body { margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial; background:var(--bg); color:var(--text); }
  header { padding:16px 20px; border-bottom:1px solid #20243a; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  header h1 { font-size:18px; margin:0; opacity:.95; white-space:nowrap; }
  .pill { background:var(--card); padding:8px 10px; border-radius:12px; border:1px solid #232744; display:flex; gap:8px; align-items:center; }
  input, select, button, textarea { background:#0c0f1c; color:var(--text); border:1px solid #27304a; border-radius:10px; padding:10px 12px; outline:none; }
  input, select, textarea { width:100%; }
  button { cursor:pointer; font-weight:600; }
  button.primary { background:#132a39; border-color:#1e3a53; }
  button:disabled { opacity:.6; cursor:not-allowed; }
  main { max-width:1400px; margin:18px auto 70px; padding:0 16px; }
  .grid { display:grid; gap:16px; grid-template-columns:repeat(12,1fr); }
  .card { grid-column:span 12; background:var(--card); border:1px solid #232744; border-radius:16px; padding:16px; }
  @media(min-width:1100px){
    .span8 { grid-column:span 8; }
    .span4 { grid-column:span 4; }
    .span7 { grid-column:span 7; }
    .span5 { grid-column:span 5; }
    .span6 { grid-column:span 6; }
  }
  .row { display:grid; gap:10px; grid-template-columns:1fr 1fr; }
  .row3 { display:grid; gap:10px; grid-template-columns:1fr 1fr 1fr; }
  .row4 { display:grid; gap:10px; grid-template-columns:1fr 1fr 1fr 1fr; }
  .label { font-size:12px; color:var(--muted); margin-bottom:6px; }
  .muted { color:var(--muted); }
  .hr { height:1px; background:#232744; margin:14px 0; }
  .hr-lg { height:1px; background:#232744; margin:18px 0; }
  details { border:1px dashed #2a3154; border-radius:12px; padding:10px 12px; }
  summary { cursor:pointer; font-weight:600; }
  code.inline { background:#0c0f1c; padding:2px 6px; border-radius:6px; border:1px solid #27304a; }
  .tabbar { display:flex; gap:6px; flex-wrap:wrap; margin-bottom:12px; }
  .tabbar button { background:transparent; border:1px solid #27304a; }
  .tabbar button.active { background:#132a39; border-color:#1e3a53; }
  .warn { color:#ffd166; }
  .ok { color:#86efac; }
  .err { color:#ff8a8a; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  .kv { display:grid; grid-template-columns: 220px 1fr; gap:8px; }
  .flex { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .list { display:block; border:1px solid #27304a; border-radius:12px; padding:8px; max-height:260px; overflow:auto; }
  .list .item { padding:8px 10px; border-bottom:1px dashed #27304a; }
  .list .item:last-child { border-bottom:none; }
  small.help { color:#9aa3b2; display:block; margin-top:4px; opacity:.9; }
  .section-title { margin:0 0 8px 0; font-size:16px; font-weight:700; }
</style>
</head>
<body>
<header>
  <h1>⚗️ Catalyst DApp</h1>

  <!-- network / rpc -->
  <div class="pill" style="min-width:340px">
    <span class="muted">RPC (read-only)</span>
    <input id="rpcUrl" placeholder="(optional) e.g. https://mainnet.infura.io/v3/…" />
    <button id="saveRpc" class="primary">Use RPC</button>
  </div>

  <!-- contract address -->
  <div class="pill" style="min-width:360px">
    <span class="muted">Contract</span>
    <input id="contractAddress" placeholder="0x… (CatalystNFTStakingUpgradeable)" />
    <button class="primary" id="saveContractBtn">Save</button>
  </div>

  <!-- wallet -->
  <div class="pill">
    <span id="acct" class="mono muted">Not connected</span>
    <button id="connectBtn" class="primary">Connect</button>
  </div>

  <!-- network info -->
  <div class="pill">
    <span class="muted">Chain</span>
    <span id="chainId" class="mono">—</span>
  </div>
</header>

<main>
  <div class="grid">
    <!-- LEFT: Tabs -->
    <section class="card span8">
      <div class="tabbar">
        <button data-tab="stake" class="active">Stake</button>
        <button data-tab="bluechip">Blue-Chip</button>
        <button data-tab="governance">Governance</button>
        <button data-tab="guardians">Guardians</button>
        <button data-tab="admin">Admin</button>
        <button data-tab="views">Views</button>
        <button data-tab="lists">Lists</button>
        <button data-tab="about">About</button>
      </div>

      <!-- Stake Tab -->
      <div class="tab" id="tab-stake" style="display:block">
        <h3 class="section-title">Custodial Staking</h3>
        <small class="help">Approve once per collection (setApprovalForAll), then stake/harvest/unstake per token ID. “Permanent” indicates no term limit (per your contract logic).</small>
        <div class="row">
          <div>
            <div class="label">Collection (ERC-721)</div>
            <input id="colStake" placeholder="0x…" />
          </div>
          <div>
            <div class="label">Token ID</div>
            <input id="tidStake" type="number" placeholder="e.g. 123" />
          </div>
        </div>
        <div class="row" style="margin-top:10px">
          <div>
            <div class="label">Stake Type</div>
            <select id="permanent">
              <option value="false">Term</option>
              <option value="true">Permanent</option>
            </select>
          </div>
          <div>
            <div class="label">Approve NFT (setApprovalForAll)</div>
            <button id="btnApprove721">Approve</button>
          </div>
        </div>
        <div class="flex" style="margin-top:10px">
          <button class="primary" id="btnStake">Stake</button>
          <button id="btnHarvestOne">Harvest</button>
          <button id="btnUnstake">Unstake</button>
          <button id="btnViewPending">View Pending</button>
          <span id="pendingView" class="mono muted">—</span>
        </div>

        <div class="hr"></div>

        <details open>
          <summary><strong>Batch stake (≤50)</strong></summary>
          <small class="help">Paste a comma-separated list of token IDs. Make sure you’ve approved the collection first.</small>
          <div class="row" style="margin-top:10px">
            <div>
              <div class="label">Collection</div>
              <input id="colBatch" placeholder="0x…">
            </div>
            <div>
              <div class="label">Token IDs (CSV)</div>
              <input id="tidsBatch" placeholder="1,2,3">
            </div>
          </div>
          <div class="row" style="margin-top:10px">
            <div>
              <div class="label">Stake Type</div>
              <select id="permanentBatch">
                <option value="false">Term</option>
                <option value="true">Permanent</option>
              </select>
            </div>
            <div>
              <div class="label">Approve</div>
              <button id="btnApprove721Batch">Approve Batch</button>
            </div>
          </div>
          <div style="margin-top:10px">
            <button class="primary" id="btnBatchStake">Batch Stake</button>
          </div>
        </details>

        <div class="hr"></div>

        <h3 class="section-title">Register Collection</h3>
        <small class="help">If the collection is not pre-registered, you can register (may require a fee depending on your contract config).</small>
        <div class="row">
          <div>
            <div class="label">Collection</div>
            <input id="colRegister" placeholder="0x…">
          </div>
          <div>
            <div class="label">Declared Max Supply (≤20,000)</div>
            <input id="declaredSupply" type="number" placeholder="10000">
          </div>
        </div>
        <div style="margin-top:10px">
          <button id="btnRegister" class="primary">Register</button>
        </div>
      </div>

      <!-- Bluechip Tab -->
      <div class="tab" id="tab-bluechip" style="display:none">
        <h3 class="section-title">Blue-Chip (Non-custodial)</h3>
        <small class="help">Blue-Chip earns via non-custodial rules if the collection is flagged as blue-chip and your wallet enrolled.</small>
        <div class="row">
          <div>
            <div class="label">Enroll Blue-Chip (one-time per wallet)</div>
            <button class="primary" id="btnEnrollBlue">Enroll</button>
          </div>
          <div>
            <div class="label">Harvest Blue-Chip — Collection</div>
            <input id="colBlueHarvest" placeholder="0x…">
          </div>
        </div>
        <div class="flex" style="margin-top:10px">
          <button id="btnHarvestBlue">Harvest Blue-Chip</button>
        </div>

        <div class="hr"></div>

        <details>
          <summary><strong>Admin: Flag / Unflag Blue-Chip Collection</strong></summary>
          <div class="row" style="margin-top:10px">
            <div>
              <div class="label">Collection</div>
              <input id="colFlagBlue" placeholder="0x…">
            </div>
            <div>
              <div class="label">Status</div>
              <select id="isBlueFlag">
                <option value="true">Flag as Blue-Chip</option>
                <option value="false">Remove Blue-Chip</option>
              </select>
            </div>
          </div>
          <div style="margin-top:10px">
            <button id="btnSetBlue" class="primary">Set Blue-Chip</button>
          </div>
        </details>
      </div>

      <!-- Governance Tab -->
      <div class="tab" id="tab-governance" style="display:none">
        <h3 class="section-title">Governance</h3>
        <small class="help">Create a proposal to change protocol parameters. Then vote and execute once quorum/time conditions are met.</small>
        <div class="row">
          <div>
            <div class="label">Proposal Type</div>
            <select id="pType">
              <option value="0">BASE_REWARD</option>
              <option value="1">HARVEST_FEE</option>
              <option value="2">UNSTAKE_FEE</option>
              <option value="3">REGISTRATION_FEE_FALLBACK</option>
              <option value="4">VOTING_PARAM</option>
              <option value="5">TIER_UPGRADE</option>
            </select>
          </div>
          <div>
            <div class="label">Param Target (for VOTING_PARAM)</div>
            <input id="paramTarget" type="number" value="0">
          </div>
        </div>
        <div class="row" style="margin-top:10px">
          <div>
            <div class="label">New Value (uint256)</div>
            <input id="newValue" type="number" placeholder="e.g. 1000">
          </div>
          <div>
            <div class="label">Collection Context (optional)</div>
            <input id="collCtx" placeholder="0x… or 0x0000…">
          </div>
        </div>
        <div style="margin-top:10px">
          <button class="primary" id="btnPropose">Create Proposal</button>
        </div>

        <div class="hr"></div>

        <div class="row">
          <div>
            <div class="label">Proposal ID (bytes32)</div>
            <input id="propId" placeholder="0x…">
          </div>
          <div>
            <div class="label">Actions</div>
            <div class="flex">
              <button id="btnVote">Vote</button>
              <button id="btnExecute">Execute</button>
            </div>
          </div>
        </div>

        <div class="hr"></div>

        <details>
          <summary><strong>Proposals (best-effort via events)</strong></summary>
          <small class="help">If your ABI emits ProposalCreated/Executed events, we’ll try to list them. Otherwise this list will remain empty.</small>
          <div class="flex" style="margin:10px 0">
            <button id="btnScanProposals" class="primary">Scan Proposals</button>
            <span class="muted">Range</span>
            <input id="scanFrom" type="number" placeholder="from block" style="width:140px">
            <input id="scanTo" type="number" placeholder="to block or blank" style="width:160px">
          </div>
          <div class="list" id="proposalList"></div>
        </details>
      </div>

      <!-- Guardians Tab -->
      <div class="tab" id="tab-guardians" style="display:none">
        <h3 class="section-title">Guardian Councils</h3>
        <small class="help">Propose, approve and execute upgrades for deployer/admin roles, plus optional direct guardian array updates (if allowed).</small>

        <details open>
          <summary><strong>Deployer Council (7:5)</strong></summary>
          <div class="row" style="margin-top:10px">
            <div>
              <div class="label">Proposed New Deployer</div>
              <input id="newDeployer" placeholder="0x…">
            </div>
            <div>
              <div class="label">Actions</div>
              <div class="flex">
                <button class="primary" id="btnPropDep">Propose</button>
                <button id="btnApproveDep">Approve</button>
                <button id="btnExecDep">Execute</button>
              </div>
            </div>
          </div>
        </details>

        <div class="hr"></div>

        <details open>
          <summary><strong>Admin Council (7:5)</strong></summary>
          <div class="row" style="margin-top:10px">
            <div>
              <div class="label">Proposed New Admin</div>
              <input id="newAdmin" placeholder="0x…">
            </div>
            <div>
              <div class="label">Actions</div>
              <div class="flex">
                <button class="primary" id="btnPropAdm">Propose</button>
                <button id="btnApproveAdm">Approve</button>
                <button id="btnExecAdm">Execute</button>
              </div>
            </div>
          </div>
        </details>

        <div class="hr"></div>

        <details>
          <summary><strong>Advanced: Set/Replace Guardians (Admin)</strong></summary>
          <div class="row3" style="margin-top:10px">
            <div>
              <div class="label">Deployer idx (0–6)</div>
              <input id="depIdx" type="number" placeholder="0">
            </div>
            <div>
              <div class="label">Guardian Address</div>
              <input id="depGuardian" placeholder="0x…">
            </div>
            <div>
              <div class="label">—</div>
              <button id="btnSetDepGuardian" class="primary">Set Deployer Guardian</button>
            </div>
          </div>
          <div class="row3" style="margin-top:10px">
            <div>
              <div class="label">Admin idx (0–6)</div>
              <input id="admIdx" type="number" placeholder="0">
            </div>
            <div>
              <div class="label">Guardian Address</div>
              <input id="admGuardian" placeholder="0x…">
            </div>
            <div>
              <div class="label">—</div>
              <button id="btnSetAdmGuardian" class="primary">Set Admin Guardian</button>
            </div>
          </div>

          <div class="hr"></div>

          <div class="flex">
            <button id="btnReadGuardians" class="primary">Read Guardian Arrays</button>
            <small class="help">Best-effort: reads deployerGuardians[i]/adminGuardians[i] for i=0..6 if exposed as public.</small>
          </div>
          <div class="list" id="guardianList"></div>
        </details>
      </div>

      <!-- Admin Tab -->
      <div class="tab" id="tab-admin" style="display:none">
        <h3 class="section-title">Admin Controls</h3>
        <div class="flex">
          <button id="btnPause">Pause</button>
          <button id="btnUnpause">Unpause</button>
        </div>

        <div class="hr"></div>

        <h4>Treasury</h4>
        <div class="row">
          <div>
            <div class="label">Withdraw → Address</div>
            <input id="toTreasury" placeholder="0x…">
          </div>
          <div>
            <div class="label">Amount (wei)</div>
            <input id="amtTreasury" type="number" placeholder="1000000000000000000">
          </div>
        </div>
        <div style="margin-top:10px">
          <button id="btnWithdraw" class="primary">Withdraw Treasury</button>
        </div>
      </div>

      <!-- Views Tab -->
      <div class="tab" id="tab-views" style="display:none">
        <h3 class="section-title">Read-Only Helpers</h3>
        <div class="row">
          <div>
            <div class="label">Pending Rewards: Collection</div>
            <input id="vCol" placeholder="0x…">
          </div>
          <div>
            <div class="label">Owner (leave blank = your address)</div>
            <input id="vOwner" placeholder="0x…">
          </div>
        </div>
        <div class="row" style="margin-top:10px">
          <div>
            <div class="label">Token ID</div>
            <input id="vTokenId" type="number" placeholder="123">
          </div>
          <div>
            <div class="label">—</div>
            <button id="btnViewPending2" class="primary">View Pending</button>
          </div>
        </div>
        <div style="margin-top:8px" class="mono muted" id="pendingOut">—</div>

        <div class="hr"></div>

        <h4>Collection Queries</h4>
        <div class="row">
          <div>
            <div class="label">Collection</div>
            <input id="qCol" placeholder="0x…">
          </div>
          <div>
            <div class="label">—</div>
            <div class="flex">
              <button id="btnIsBlue">isBluechipCollection</button>
              <button id="btnRegIndex">registeredIndex</button>
            </div>
          </div>
        </div>
        <div class="mono muted" id="qOut" style="margin-top:8px">—</div>
      </div>

      <!-- Lists Tab -->
      <div class="tab" id="tab-lists" style="display:none">
        <h3 class="section-title">On-Chain Lists</h3>
        <small class="help">Best-effort iteration with graceful fallback. If a view is unsupported in your ABI, the section remains empty.</small>
        <details open>
          <summary><strong>Registered Collections</strong></summary>
          <div class="flex" style="margin:10px 0">
            <button id="btnScanCollections" class="primary">Scan</button>
            <span class="muted">Max</span>
            <input id="scanMaxCols" type="number" value="200" style="width:120px">
          </div>
          <div class="list" id="collectionsList"></div>
        </details>

        <div class="hr"></div>

        <details>
          <summary><strong>Guardians (read)</strong></summary>
          <div class="flex" style="margin:10px 0">
            <button id="btnScanGuardians" class="primary">Scan</button>
          </div>
          <div class="list" id="guardiansList"></div>
        </details>
      </div>

      <!-- About Tab -->
      <div class="tab" id="tab-about" style="display:none">
        <h3 class="section-title">About this DApp</h3>
        <p class="muted">Reads use a public/your-RPC provider (cheap & safe). Writes use your connected wallet’s signer. You can run reads without connecting a wallet; only transactions prompt your wallet.</p>
        <ul class="muted">
          <li><span class="mono">Stake</span> — Approve NFT, stake, harvest, unstake. Batch stake supported.</li>
          <li><span class="mono">Blue-Chip</span> — Enroll once. Harvest rewards per collection. Admin can flag blue-chip collections.</li>
          <li><span class="mono">Governance</span> — Create proposals, vote, execute. Event scan is best-effort.</li>
          <li><span class="mono">Guardians</span> — Deployer/Admin councils (propose/approve/execute). Optional direct array setters/readers.</li>
          <li><span class="mono">Admin</span> — Pause/unpause, withdraw treasury.</li>
          <li><span class="mono">Views</span> — Quick read helpers (pending rewards, collection queries).</li>
          <li><span class="mono">Lists</span> — Registered collections & guardians (best-effort scan).</li>
        </ul>
      </div>
    </section>

    <!-- RIGHT: Stats + User/Collection Info + Console -->
    <section class="card span4">
      <!-- Protocol Stats -->
      <div class="flex" style="justify-content:space-between; align-items:center">
        <h3 class="section-title">Protocol Stats</h3>
        <div class="flex">
          <button id="btnRefresh" class="primary">Refresh</button>
          <label class="muted" style="display:flex; align-items:center; gap:6px">
            <input type="checkbox" id="autoRefresh" />
            Auto
          </label>
        </div>
      </div>

      <div id="stats" class="mono">
        <div class="kv">
          <div>totalAll</div><div id="st_totalAll">—</div>
          <div>totalTerm</div><div id="st_totalTerm">—</div>
          <div>totalPermanent</div><div id="st_totalPermanent">—</div>
          <div>remainingGlobal</div><div id="st_remainingGlobal">—</div>
          <div>remainingTerm</div><div id="st_remainingTerm">—</div>
          <div>remainingPermanent</div><div id="st_remainingPermanent">—</div>
          <div>treasuryBalance</div><div id="st_treasury">—</div>
          <div>deployerAddress</div><div id="st_deployer">—</div>
          <div>paused</div><div id="st_paused">—</div>
        </div>
      </div>

      <div class="hr-lg"></div>

      <!-- User & Collection Info (mirrors Stats style) -->
      <h3 class="section-title">User & Collection Info</h3>
      <div class="row">
        <div>
          <div class="label">Collection</div>
          <input id="infoCol" placeholder="0x…" />
        </div>
        <div>
          <div class="label">User</div>
          <input id="infoUser" placeholder="0x… (blank = your wallet)" />
        </div>
      </div>
      <div class="flex" style="margin-top:10px">
        <button id="btnUserInfo" class="primary">Get User Info</button>
        <button id="btnColInfo">Get Collection Info</button>
        <button id="btnListRegs">List Registered (best-effort)</button>
      </div>

      <div class="hr"></div>

      <div class="mono">
        <div class="kv">
          <div><strong>User Info</strong></div><div></div>
          <div>Address</div><div id="ui_addr">—</div>
          <div>Collection</div><div id="ui_col">—</div>
          <div>Pending (tid=0)</div><div id="ui_pending">—</div>
        </div>
        <div class="hr"></div>
        <div class="kv">
          <div><strong>Collection Info</strong></div><div></div>
          <div>Address</div><div id="ci_addr">—</div>
          <div>Index</div><div id="ci_index">—</div>
          <div>Blue-Chip?</div><div id="ci_blue">—</div>
        </div>
        <div class="hr"></div>
        <div>
          <div><strong>Registered Collections</strong></div>
          <div id="ci_regs" class="list" style="margin-top:6px; max-height:180px"></div>
        </div>
      </div>

      <div class="hr-lg"></div>

      <!-- Console -->
      <h3 class="section-title">Console</h3>
      <div id="log" class="mono" style="font-size:12px; white-space:pre-wrap; min-height:200px"></div>
    </section>
  </div>
</main>

<script>
/** =========================
 * CONFIG & CONSTANTS
 * ======================= */
const ABI_URL = "../abi/CatalystNFTStakingUpgradeable.json"; // <— keep this path pointing to your repo file
const DEFAULT_CONTRACT = "";  // optional
const DEFAULT_RPC = "";       // optional
const MAX_GUARDIANS = 7;      // per your design
const ZERO = "0x0000000000000000000000000000000000000000";

// Minimal ERC-721 ABI for approvals
const ERC721_ABI = [
  "function setApprovalForAll(address operator, bool approved)",
  "function isApprovedForAll(address owner, address operator) view returns (bool)"
];

// Known views we depend on. Others are loaded from ABI_URL dynamically.
const KNOWN_READS = [
  "function stakingStats() view returns (uint256 totalAll, uint256 totalTerm, uint256 totalPermanent, uint256 remainingGlobal, uint256 remainingTerm, uint256 remainingPermanent)",
  "function pendingRewardsView(address collection, address owner, uint256 tokenId) view returns (uint256)",
  "function treasuryBalance() view returns (uint256)",
  "function paused() view returns (bool)",
  "function deployerAddress() view returns (address)",
  "function isBluechipCollection(address collection) view returns (bool)",
  "function registeredIndex(address collection) view returns (uint256)"
  // Optional (if present in ABI JSON): registeredCollections(uint256), deployerGuardians(uint256), adminGuardians(uint256)
];

// State
let READ_PROVIDER = null;   // ethers.Provider (read-only)
let WALLET_PROVIDER = null; // BrowserProvider (MetaMask etc.)
let SIGNER = null;
let USER_ADDR = null;

let ABI = null;
let READ_CONTRACT = null;   // read provider
let WRITE_CONTRACT = null;  // signer
let CONTRACT_ADDR = "";     // from input/localStorage

let refreshTimer = null;

/** =========================
 * DOM SHORTCUTS & LOGGING
 * ======================= */
const $ = (id) => document.getElementById(id);
const log = (msg, cls="") => {
  const el = $("log");
  const line = document.createElement("div");
  if (cls) line.className = cls;
  line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
  el.prepend(line);
};

/** =========================
 * ABI LOADER
 * ======================= */
async function loadABI() {
  if (ABI) return ABI;
  const res = await fetch(ABI_URL, { cache: "no-store" });
  if (!res.ok) throw new Error(`Failed to load ABI JSON from ${ABI_URL}`);
  const json = await res.json();
  // Truffle/Hardhat artifact support
  let arr = Array.isArray(json) ? json : (json.abi || json.ABI || json.default || json);
  if (!Array.isArray(arr)) throw new Error("ABI JSON not in expected format");
  // Ensure known reads are present (some builds omit returns clarity)
  // We just append our minimal reads if not present to avoid dev-build issues.
  const textified = new Set(arr.map(x => (typeof x === "string" ? x.trim() : JSON.stringify(x))));
  for (const sig of KNOWN_READS) {
    if (![...textified].some(s => s.includes("stakingStats") && sig.includes("stakingStats")) && sig.includes("stakingStats")) arr.push(sig);
    if (![...textified].some(s => s.includes("pendingRewardsView")) && sig.includes("pendingRewardsView")) arr.push(sig);
    if (![...textified].some(s => s.includes("treasuryBalance")) && sig.includes("treasuryBalance")) arr.push(sig);
    if (![...textified].some(s => s.includes("paused") && !s.includes("pause(")) && sig.includes("paused()")) arr.push(sig);
    if (![...textified].some(s => s.includes("deployerAddress")) && sig.includes("deployerAddress")) arr.push(sig);
    if (![...textified].some(s => s.includes("isBluechipCollection")) && sig.includes("isBluechipCollection")) arr.push(sig);
    if (![...textified].some(s => s.includes("registeredIndex")) && sig.includes("registeredIndex")) arr.push(sig);
  }
  ABI = arr;
  log(`ABI loaded (${ABI.length} entries)`, "ok");
  return ABI;
}

/** =========================
 * PROVIDERS (READ / WRITE)
 * ======================= */
async function setupReadProvider(customRpc) {
  try {
    READ_PROVIDER = customRpc
      ? new ethers.JsonRpcProvider(customRpc)
      : ethers.getDefaultProvider(); // fallback (rate-limited)
    const net = await READ_PROVIDER.getNetwork();
    $("chainId").textContent = Number(net.chainId).toString();
    log(`Read provider set on chainId ${Number(net.chainId)}`, "ok");
  } catch (e) {
    log(`Failed to set read provider: ${e.message || e}`, "err");
    READ_PROVIDER = null;
  }
}

async function connectWallet() {
  if (!window.ethereum) throw new Error("No injected wallet found");
  WALLET_PROVIDER = new ethers.BrowserProvider(window.ethereum);
  await WALLET_PROVIDER.send("eth_requestAccounts", []);
  SIGNER = await WALLET_PROVIDER.getSigner();
  USER_ADDR = await SIGNER.getAddress();
  $("acct").textContent = USER_ADDR;
  const net = await WALLET_PROVIDER.getNetwork();
  $("chainId").textContent = Number(net.chainId).toString();
  log(`Wallet connected: ${USER_ADDR}`, "ok");
}

/** =========================
 * CONTRACT INIT
 * ======================= */
function saveContractAddress(addr) {
  localStorage.setItem("catalyst_contract", addr);
  $("contractAddress").value = addr;
  CONTRACT_ADDR = addr;
  log(`Saved contract address: ${addr}`, "ok");
}
function getSavedAddress() {
  return localStorage.getItem("catalyst_contract") || DEFAULT_CONTRACT;
}
async function initReadContract() {
  if (!CONTRACT_ADDR) throw new Error("Contract address is empty");
  if (!READ_PROVIDER) await setupReadProvider(localStorage.getItem("catalyst_rpc") || DEFAULT_RPC);
  const abi = await loadABI();
  READ_CONTRACT = new ethers.Contract(CONTRACT_ADDR, abi, READ_PROVIDER);
  return READ_CONTRACT;
}
async function initWriteContract() {
  if (!SIGNER) await connectWallet();
  if (!CONTRACT_ADDR) throw new Error("Contract address is empty");
  const abi = await loadABI();
  WRITE_CONTRACT = new ethers.Contract(CONTRACT_ADDR, abi, SIGNER);
  return WRITE_CONTRACT;
}

/** =========================
 * HELPERS
 * ======================= */
function parseAddress(v) {
  const s = (v || "").trim();
  if (!ethers.isAddress(s)) throw new Error("Invalid address");
  return s;
}
function parseUint(v, fallback=0n) {
  const s = (v ?? "").toString().trim();
  if (!s) return BigInt(fallback);
  return BigInt(s);
}
function parseIdsCSV(csv) {
  return (csv || "")
    .split(",")
    .map(s => s.trim())
    .filter(Boolean)
    .map(s => BigInt(s));
}
function prettyWei(bi) {
  try { return ethers.formatEther(bi); } catch { return bi?.toString?.() ?? String(bi); }
}

/** =========================
 * STATS (READ-ONLY)
 * ======================= */
async function refreshStats() {
  try {
    await initReadContract();
    const s = await READ_CONTRACT.stakingStats();
    $("st_totalAll").textContent = s.totalAll.toString();
    $("st_totalTerm").textContent = s.totalTerm.toString();
    $("st_totalPermanent").textContent = s.totalPermanent.toString();
    $("st_remainingGlobal").textContent = s.remainingGlobal.toString();
    $("st_remainingTerm").textContent = s.remainingTerm.toString();
    $("st_remainingPermanent").textContent = s.remainingPermanent.toString();

    const tb = await READ_CONTRACT.treasuryBalance();
    $("st_treasury").textContent = `${tb.toString()} (${prettyWei(tb)} ETH)`;

    // optional reads
    let dep = "—", isPaused = "—";
    try { dep = await READ_CONTRACT.deployerAddress(); } catch {}
    try { isPaused = await READ_CONTRACT.paused(); } catch {}
    $("st_deployer").textContent = dep;
    $("st_paused").textContent = isPaused === true ? "true" : (isPaused === false ? "false" : "—");

    log("Stats refreshed ✅", "ok");
  } catch (e) {
    log(`Stats error: ${e.message || e}`, "err");
  }
}

function toggleAutoRefresh(on) {
  if (refreshTimer) {
    clearInterval(refreshTimer);
    refreshTimer = null;
  }
  if (on) refreshTimer = setInterval(refreshStats, 8000);
}

/** =========================
 * USER & COLLECTION INFO PANEL (RIGHT)
 * ======================= */
async function renderUserInfo() {
  try {
    await initReadContract();
    const col = parseAddress($("infoCol").value);
    let usr = $("infoUser").value.trim();
    if (!usr) usr = USER_ADDR || "";
    const owner = parseAddress(usr);

    let pending = "—";
    try {
      const r = await READ_CONTRACT.pendingRewardsView(col, owner, 0n);
      pending = `${r.toString()} (${prettyWei(r)} ETH)`;
    } catch {}

    $("ui_addr").textContent = owner;
    $("ui_col").textContent = col;
    $("ui_pending").textContent = pending;

    log("User info fetched ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
}

async function renderCollectionInfo() {
  try {
    await initReadContract();
    const col = parseAddress($("infoCol").value);

    $("ci_addr").textContent = col;

    let idx="—", blue="—";
    try { idx = (await READ_CONTRACT.registeredIndex(col)).toString(); } catch {}
    try { blue = (await READ_CONTRACT.isBluechipCollection(col)) ? "true" : "false"; } catch {}
    $("ci_index").textContent = idx;
    $("ci_blue").textContent = blue;

    log("Collection info fetched ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
}

async function listRegisteredCollections(limit=200) {
  try {
    await initReadContract();
    const out = $("ci_regs");
    out.innerHTML = "";
    // best-effort iteration registeredCollections(uint index) if ABI exposes it
    let found = 0;
    for (let i=0; i<limit; i++){
      try {
        const addr = await READ_CONTRACT.registeredCollections(i);
        if (!addr || addr === ZERO) break;
        const div = document.createElement("div");
        div.className="item mono";
        div.textContent = `${i}: ${addr}`;
        out.appendChild(div);
        found++;
      } catch {
        // stop on first failure (no such function or index out)
        if (i===0) {
          const div = document.createElement("div");
          div.className="item mono muted";
          div.textContent = "registeredCollections(index) view not available in this ABI.";
          out.appendChild(div);
        }
        break;
      }
    }
    if (found===0) {
      const div = document.createElement("div");
      div.className="item mono muted";
      div.textContent = "No collections discovered (or method unavailable).";
      out.appendChild(div);
    }
    log("Registered collections scan complete ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
}

/** =========================
 * AUTO-RESTORE ON REFRESH
 * ======================= */
window.addEventListener("load", async () => {
  try {
    // Restore RPC
    const savedRpc = localStorage.getItem("catalyst_rpc") || DEFAULT_RPC;
    $("rpcUrl").value = savedRpc;
    await setupReadProvider(savedRpc);

    // Restore contract address
    const savedAddr = localStorage.getItem("catalyst_contract") || DEFAULT_CONTRACT;
    if (savedAddr) {
      CONTRACT_ADDR = savedAddr;
      $("contractAddress").value = CONTRACT_ADDR;
      await initReadContract(); // preload ABI + read contract
    }

    // Try restoring wallet connection silently
    if (window.ethereum) {
      const accounts = await window.ethereum.request({ method: "eth_accounts" });
      if (accounts.length > 0) {
        WALLET_PROVIDER = new ethers.BrowserProvider(window.ethereum);
        SIGNER = await WALLET_PROVIDER.getSigner();
        USER_ADDR = accounts[0];
        $("acct").textContent = USER_ADDR;
        log(`Restored wallet: ${USER_ADDR}`, "ok");
      } else {
        $("acct").textContent = "Not connected";
      }
    }

    // Tabs switching
    document.querySelectorAll(".tabbar button").forEach(btn => {
      btn.onclick = () => {
        document.querySelectorAll(".tabbar button").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        const key = btn.dataset.tab;
        document.querySelectorAll(".tab").forEach(t => t.style.display="none");
        $("tab-" + key).style.display = "block";
      };
    });

    // Header buttons wiring (Connect / Save RPC / Save Contract)
    $("connectBtn").onclick = async () => {
      try { await connectWallet(); } catch (e) { log(e.message || e, "err"); }
    };
    $("saveRpc").onclick = async () => {
      const url = $("rpcUrl").value.trim();
      localStorage.setItem("catalyst_rpc", url);
      await setupReadProvider(url);
      if (CONTRACT_ADDR) {
        try { await initReadContract(); log("Read contract re-initialized with new RPC", "ok"); }
        catch(e){ log(e.message || e, "err"); }
      }
    };
    $("saveContractBtn").onclick = () => {
      try { saveContractAddress($("contractAddress").value.trim()); }
      catch(e){ log(e.message || e, "err"); }
    };

    // Auto-refresh stats once
    if (CONTRACT_ADDR) {
      await refreshStats();
    }

    log("DApp ready ✅ — restored state from last session", "ok");
  } catch (e) {
    log(`Init error: ${e.message || e}`, "err");
  }
});
  
/** =========================
 * STAKE TAB ACTIONS
 * ======================= */
$("btnApprove721").onclick = async () => {
  try {
    await initWriteContract();
    const col = parseAddress($("colStake").value);
    const nft = new ethers.Contract(col, ERC721_ABI, SIGNER);
    const tx = await nft.setApprovalForAll(CONTRACT_ADDR, true);
    log(`Approve tx: ${tx.hash}`);
    await tx.wait();
    log("Approved setApprovalForAll ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
};

$("btnStake").onclick = async () => {
  try{
    await initWriteContract();
    const col = parseAddress($("colStake").value);
    const id = parseUint($("tidStake").value);
    const permanent = $("permanent").value === "true";
    const tx = await WRITE_CONTRACT.stake(col, id, permanent);
    log(`Stake sent: ${tx.hash}`); await tx.wait(); log("Stake confirmed ✅", "ok");
    refreshStats();
  } catch(e){ log(e.message || e, "err"); }
};

$("btnHarvestOne").onclick = async () => {
  try{
    await initWriteContract();
    const col = parseAddress($("colStake").value);
    const id = parseUint($("tidStake").value);
    const tx = await WRITE_CONTRACT.harvest(col, id);
    log(`Harvest sent: ${tx.hash}`); await tx.wait(); log("Harvest confirmed ✅", "ok");
    refreshStats();
  } catch(e){ log(e.message || e, "err"); }
};

$("btnUnstake").onclick = async () => {
  try{
    await initWriteContract();
    const col = parseAddress($("colStake").value);
    const id = parseUint($("tidStake").value);
    const tx = await WRITE_CONTRACT.unstake(col, id);
    log(`Unstake sent: ${tx.hash}`); await tx.wait(); log("Unstake confirmed ✅", "ok");
    refreshStats();
  } catch(e){ log(e.message || e, "err"); }
};

$("btnViewPending").onclick = async () => {
  try{
    await initReadContract();
    const col = parseAddress($("colStake").value);
    const id = parseUint($("tidStake").value);
    const owner = USER_ADDR || $("infoUser").value.trim();
    const addr = owner && ethers.isAddress(owner) ? owner : (()=>{ throw new Error("Connect wallet or enter owner (right panel)"); })();
    const r = await READ_CONTRACT.pendingRewardsView(col, addr, id);
    $("pendingView").textContent = `${r.toString()} (${prettyWei(r)} ETH)`;
    log("Pending rewards fetched ✅","ok");
  } catch(e){ log(e.message || e, "err"); }
};

$("btnApprove721Batch").onclick = async () => {
  try {
    await initWriteContract();
    const col = parseAddress($("colBatch").value);
    const nft = new ethers.Contract(col, ERC721_ABI, SIGNER);
    const tx = await nft.setApprovalForAll(CONTRACT_ADDR, true);
    log(`Approve batch tx: ${tx.hash}`); await tx.wait(); log("Approved ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
};

$("btnBatchStake").onclick = async () => {
  try{
    await initWriteContract();
    const col = parseAddress($("colBatch").value);
    const ids = parseIdsCSV($("tidsBatch").value);
    if (ids.length === 0) throw new Error("No token ids");
    const permanent = $("permanentBatch").value === "true";
    const tx = await WRITE_CONTRACT.batchStake(col, ids, permanent);
    log(`Batch stake: ${tx.hash}`); await tx.wait(); log("Batch stake confirmed ✅", "ok");
    refreshStats();
  } catch(e){ log(e.message || e, "err"); }
};

$("btnRegister").onclick = async () => {
  try{
    await initWriteContract();
    const col = parseAddress($("colRegister").value);
    const supply = parseUint($("declaredSupply").value);
    const tx = await WRITE_CONTRACT.registerCollection(col, supply);
    log(`Register sent: ${tx.hash}`); await tx.wait(); log("Collection registered ✅", "ok");
    refreshStats();
  } catch(e){ log(e.message || e, "err"); }
};

/** =========================
 * BLUE-CHIP TAB
 * ======================= */
$("btnEnrollBlue").onclick = async () => {
  try{
    await initWriteContract();
    const tx = await WRITE_CONTRACT.enrollBluechip();
    log(`Enroll sent: ${tx.hash}`); await tx.wait(); log("Enrolled ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
};
$("btnHarvestBlue").onclick = async () => {
  try{
    await initWriteContract();
    const col = parseAddress($("colBlueHarvest").value);
    const tx = await WRITE_CONTRACT.harvestBluechip(col);
    log(`Harvest blue-chip: ${tx.hash}`); await tx.wait(); log("Blue-chip harvested ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
};
$("btnSetBlue").onclick = async () => {
  try{
    await initWriteContract();
    const col = parseAddress($("colFlagBlue").value);
    const isBlue = $("isBlueFlag").value === "true";
    const tx = await WRITE_CONTRACT.setBluechipCollection(col, isBlue);
    log(`Set blue-chip: ${tx.hash}`); await tx.wait(); log("Blue-chip flag updated ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
};

/** =========================
 * GOVERNANCE TAB
 * ======================= */
$("btnPropose").onclick = async () => {
  try{
    await initWriteContract();
    const pType = Number($("pType").value);
    const paramTarget = Number($("paramTarget").value || "0");
    const newValue = parseUint($("newValue").value);
    const ctx = ($("collCtx").value.trim() || ZERO);
    const tx = await WRITE_CONTRACT.propose(pType, paramTarget, newValue, ctx);
    log(`Propose sent: ${tx.hash}`);
    await tx.wait();
    log("Proposal created (check explorer logs) ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
};
$("btnVote").onclick = async () => {
  try{
    await initWriteContract();
    const id = $("propId").value.trim();
    const tx = await WRITE_CONTRACT.vote(id);
    log(`Vote sent: ${tx.hash}`); await tx.wait(); log("Voted ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
};
$("btnExecute").onclick = async () => {
  try{
    await initWriteContract();
    const id = $("propId").value.trim();
    const tx = await WRITE_CONTRACT.executeProposal(id);
    log(`Execute sent: ${tx.hash}`); await tx.wait(); log("Executed ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
};

// Best-effort proposals scan by events
$("btnScanProposals").onclick = async () => {
  try {
    await initReadContract();
    const list = $("proposalList");
    list.innerHTML = "";
    let from = $("scanFrom").value ? Number($("scanFrom").value) : 0;
    let to = $("scanTo").value ? Number($("scanTo").value) : undefined;

    // Try common event names
    const tryEvent = async (name) => {
      try {
        const ev = READ_CONTRACT.getEvent(name);
        const logs = await READ_CONTRACT.queryFilter(ev, from, to);
        logs.forEach((lg, i) => {
          const div = document.createElement("div");
          div.className = "item mono";
          div.textContent = `${name} #${i} @${lg.blockNumber} tx:${lg.transactionHash}`;
          list.appendChild(div);
        });
        return logs.length;
      } catch { return 0; }
    };

    let total = 0;
    total += await tryEvent("ProposalCreated");
    total += await tryEvent("ProposalExecuted");
    total += await tryEvent("Voted");

    if (total === 0) {
      const div = document.createElement("div");
      div.className="item mono muted";
      div.textContent = "No governance events found (or events not in ABI).";
      list.appendChild(div);
    }
    log("Proposal scan done ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
};

/** =========================
 * GUARDIANS TAB
 * ======================= */
$("btnPropDep").onclick = async () => {
  try{
    await initWriteContract();
    const addr = parseAddress($("newDeployer").value);
    const tx = await WRITE_CONTRACT.proposeDeployerRecovery(addr);
    log(`Proposed new deployer: ${tx.hash}`); await tx.wait(); log("Proposal acknowledged ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
};
$("btnApproveDep").onclick = async () => {
  try{
    await initWriteContract();
    const tx = await WRITE_CONTRACT.approveDeployerRecovery();
    log(`Approve deployer: ${tx.hash}`); await tx.wait(); log("Approved ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
};
$("btnExecDep").onclick = async () => {
  try{
    await initWriteContract();
    const tx = await WRITE_CONTRACT.executeDeployerRecovery();
    log(`Execute deployer: ${tx.hash}`); await tx.wait(); log("Deployer recovered ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
};

$("btnPropAdm").onclick = async () => {
  try{
    await initWriteContract();
    const addr = parseAddress($("newAdmin").value);
    const tx = await WRITE_CONTRACT.proposeAdminRecovery(addr);
    log(`Proposed new admin: ${tx.hash}`); await tx.wait(); log("Proposal acknowledged ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
};
$("btnApproveAdm").onclick = async () => {
  try{
    await initWriteContract();
    const tx = await WRITE_CONTRACT.approveAdminRecovery();
    log(`Approve admin: ${tx.hash}`); await tx.wait(); log("Approved ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
};
$("btnExecAdm").onclick = async () => {
  try{
    await initWriteContract();
    const tx = await WRITE_CONTRACT.executeAdminRecovery();
    log(`Execute admin: ${tx.hash}`); await tx.wait(); log("Admin recovered ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
};

$("btnSetDepGuardian").onclick = async () => {
  try{
    await initWriteContract();
    const idx = Number($("depIdx").value || "0");
    const gaddr = parseAddress($("depGuardian").value);
    const tx = await WRITE_CONTRACT.setDeployerGuardian(idx, gaddr);
    log(`Set deployer guardian: ${tx.hash}`); await tx.wait(); log("Deployer guardian set ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
};
$("btnSetAdmGuardian").onclick = async () => {
  try{
    await initWriteContract();
    const idx = Number($("admIdx").value || "0");
    const gaddr = parseAddress($("admGuardian").value);
    const tx = await WRITE_CONTRACT.setAdminGuardian(idx, gaddr);
    log(`Set admin guardian: ${tx.hash}`); await tx.wait(); log("Admin guardian set ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
};

$("btnReadGuardians").onclick = async () => {
  try {
    await initReadContract();
    const list = $("guardianList");
    list.innerHTML = "";
    let any = false;
    // Try to read arrays deployerGuardians(i) & adminGuardians(i)
    for (let i=0; i<MAX_GUARDIANS; i++) {
      try {
        const a = await READ_CONTRACT.deployerGuardians(i);
        const div = document.createElement("div");
        div.className="item mono";
        div.textContent = `deployerGuardians[${i}] = ${a}`;
        list.appendChild(div);
        any = true;
      } catch { break; }
    }
    for (let i=0; i<MAX_GUARDIANS; i++) {
      try {
        const a = await READ_CONTRACT.adminGuardians(i);
        const div = document.createElement("div");
        div.className="item mono";
        div.textContent = `adminGuardians[${i}] = ${a}`;
        list.appendChild(div);
        any = true;
      } catch { break; }
    }
    if (!any) {
      const div = document.createElement("div");
      div.className="item mono muted";
      div.textContent = "Guardian arrays not exposed as public in this ABI.";
      list.appendChild(div);
    }
    log("Guardian read complete ✅", "ok");
  } catch(e){ log(e.message || e, "err"); }
};

/** =========================
 * ADMIN TAB
 * ======================= */
$("btnPause").onclick = async () => {
  try{ await initWriteContract(); const tx = await WRITE_CONTRACT.pause(); log(`Pause: ${tx.hash}`); await tx.wait(); log("Paused ✅","ok"); refreshStats();
  } catch(e){ log(e.message || e, "err"); }
};
$("btnUnpause").onclick = async () => {
  try{ await initWriteContract(); const tx = await WRITE_CONTRACT.unpause(); log(`Unpause: ${tx.hash}`); await tx.wait(); log("Unpaused ✅","ok"); refreshStats();
  } catch(e){ log(e.message || e, "err"); }
};
$("btnWithdraw").onclick = async () => {
  try{
    await initWriteContract();
    const to = parseAddress($("toTreasury").value);
    const amt = parseUint($("amtTreasury").value);
    const tx = await WRITE_CONTRACT.withdrawTreasury(to, amt);
    log(`Withdraw: ${tx.hash}`); await tx.wait(); log("Treasury withdrawn ✅", "ok"); refreshStats();
  } catch(e){ log(e.message || e, "err"); }
};

/** =========================
 * VIEWS TAB (read-only helpers)
 * ======================= */
$("btnViewPending2").onclick = async () => {
  try{
    await initReadContract();
    const col = parseAddress($("vCol").value);
    let owner = $("vOwner").value.trim();
    if (!owner) owner = USER_ADDR || "";
    const own = parseAddress(owner);
    const tid = parseUint($("vTokenId").value);
    const r = await READ_CONTRACT.pendingRewardsView(col, own, tid);
    $("pendingOut").textContent = `${r.toString()} (${prettyWei(r)} ETH)`;
    log("Pending rewards (Views) fetched ✅","ok");
  } catch(e){ log(e.message || e, "err"); }
};
$("btnIsBlue").onclick = async () => {
  try {
    await initReadContract();
    const col = parseAddress($("qCol").value);
    const r = await READ_CONTRACT.isBluechipCollection(col);
    $("qOut").textContent = `isBluechipCollection(${col}) = ${r}`;
  } catch(e){ $("qOut").textContent = e.message || String(e); log(e.message || e, "err"); }
};
$("btnRegIndex").onclick = async () => {
  try {
    await initReadContract();
    const col = parseAddress($("qCol").value);
    const r = await READ_CONTRACT.registeredIndex(col);
    $("qOut").textContent = `registeredIndex(${col}) = ${r}`;
  } catch(e){ $("qOut").textContent = e.message || String(e); log(e.message || e, "err"); }
};

/** =========================
 * RIGHT PANEL (User & Collection Info)
 * ======================= */
$("btnUserInfo").onclick = renderUserInfo;
$("btnColInfo").onclick = renderCollectionInfo;
$("btnListRegs").onclick = () => {
  const lim = Number(prompt("Max entries to try?", "200") || "200");
  listRegisteredCollections(lim);
};

/** =========================
 * LISTS TAB (Registered Collections & Guardians)
 * ======================= */
$("btnScanCollections").onclick = async () => {
  const n = Number($("scanMaxCols").value || "200");
  await listRegisteredCollections(n);
};
$("btnScanGuardians").onclick = async () => {
  // reuse the same as guardians read
  await (async () => {
    try {
      await initReadContract();
      const list = $("guardiansList");
      list.innerHTML = "";
      let any = false;
      for (let i=0; i<MAX_GUARDIANS; i++) {
        try {
          const a = await READ_CONTRACT.deployerGuardians(i);
          const div = document.createElement("div");
          div.className="item mono";
          div.textContent = `deployerGuardians[${i}] = ${a}`;
          list.appendChild(div);
          any = true;
        } catch { break; }
      }
      for (let i=0; i<MAX_GUARDIANS; i++) {
        try {
          const a = await READ_CONTRACT.adminGuardians(i);
          const div = document.createElement("div");
          div.className="item mono";
          div.textContent = `adminGuardians[${i}] = ${a}`;
          list.appendChild(div);
          any = true;
        } catch { break; }
      }
      if (!any) {
        const div = document.createElement("div");
        div.className="item mono muted";
        div.textContent = "Guardian arrays not exposed as public in this ABI.";
        list.appendChild(div);
      }
      log("Guardians scan complete ✅", "ok");
    } catch(e){ log(e.message || e, "err"); }
  })();
};

  <script>
/** =========================
 * AUTO-INIT (FAST UI FIRST)
 * ======================= */

// ⚡ Wire UI instantly on DOM ready
document.addEventListener("DOMContentLoaded", () => {
  // Tabs
  document.querySelectorAll(".tabbar button").forEach(btn => {
    btn.onclick = () => {
      document.querySelectorAll(".tabbar button").forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      const key = btn.dataset.tab;
      document.querySelectorAll(".tab").forEach(t => t.style.display="none");
      document.getElementById("tab-" + key).style.display = "block";
    };
  });

  // Connect Wallet (always available)
  document.getElementById("connectBtn").onclick = async () => {
    try { await connectWallet(); }
    catch(e){ log(e.message || e, "err"); }
  };

  // Contract + RPC save buttons
  document.getElementById("saveContractBtn").onclick = () => {
    try { saveContractAddress(document.getElementById("contractAddress").value.trim()); }
    catch(e){ log(e.message || e, "err"); }
  };
  document.getElementById("saveRpc").onclick = async () => {
    const url = document.getElementById("rpcUrl").value.trim();
    localStorage.setItem("catalyst_rpc", url);
    await setupReadProvider(url);
    if (CONTRACT_ADDR) {
      try { await initReadContract(); log("Re-initialized with new RPC ✅", "ok"); }
      catch(e){ log(e.message || e, "err"); }
    }
  };

  // Stats auto-refresh controls
  document.getElementById("btnRefresh").onclick = refreshStats;
  document.getElementById("autoRefresh").onchange = (e) => toggleAutoRefresh(e.target.checked);

  log("UI wired instantly ⚡", "ok");
});

// 🐢 Background init (non-blocking)
window.addEventListener("load", async () => {
  try {
    // Restore RPC
    const savedRpc = localStorage.getItem("catalyst_rpc") || DEFAULT_RPC;
    document.getElementById("rpcUrl").value = savedRpc;
    await setupReadProvider(savedRpc);

    // Restore contract
    const savedAddr = localStorage.getItem("catalyst_contract") || DEFAULT_CONTRACT;
    if (savedAddr) {
      CONTRACT_ADDR = savedAddr;
      document.getElementById("contractAddress").value = CONTRACT_ADDR;
      await initReadContract(); // preload ABI + contract
    }

    // Try restoring wallet silently
    if (window.ethereum) {
      const accounts = await window.ethereum.request({ method: "eth_accounts" });
      if (accounts.length > 0) {
        WALLET_PROVIDER = new ethers.BrowserProvider(window.ethereum);
        SIGNER = await WALLET_PROVIDER.getSigner();
        USER_ADDR = accounts[0];
        document.getElementById("acct").textContent = USER_ADDR;
        log(`Restored wallet: ${USER_ADDR}`, "ok");
      } else {
        document.getElementById("acct").textContent = "Not connected";
      }
    }

    // Initial stats
    if (CONTRACT_ADDR) await refreshStats();

    log("Background init complete ✅", "ok");
  } catch (e) {
    log(`Init error: ${e.message || e}`, "err");
  }
});
</script>

</script>
</body>
</html>
