// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/* ──────────────────────────────────────────────────────────────
   StakingLib
─────────────────────────────────────────────────────────────── */
library StakingLib {
    uint256 public constant GLOBAL_CAP = 1_000_000_000;
    uint256 public constant TERM_CAP   = 750_000_000;
    uint256 public constant PERM_CAP   = 250_000_000;

    struct StakeInfo {
        uint256 stakeBlock;
        uint256 lastHarvestBlock;
        bool currentlyStaked;
        bool isPermanent;
        uint256 unstakeDeadlineBlock;
    }

    struct CollectionConfig {
        uint256 totalStaked;
        uint256 totalStakers;
        bool registered;
        uint256 declaredSupply;
    }

    struct Storage {
        uint256 totalStakedAll;
        uint256 totalStakedTerm;
        uint256 totalStakedPermanent;

        mapping(address => CollectionConfig) collectionConfigs;
        mapping(address => mapping(address => mapping(uint256 => StakeInfo))) stakeLog;
        mapping(address => mapping(address => uint256[])) stakePortfolioByUser;
        mapping(address => mapping(uint256 => uint256)) indexOfTokenIdInStakePortfolio;
        uint256 totalStakedNFTsCount;
        uint256 baseRewardRate;
    }

    event InternalStakeRecorded(address indexed owner, address indexed collection, uint256 indexed tokenId);
    event InternalUnstakeRecorded(address indexed owner, address indexed collection, uint256 indexed tokenId);

    function initCollection(Storage storage s, address collection, uint256 declaredSupply) internal {
        require(collection != address(0), "StakingLib: zero collection");
        CollectionConfig storage cfg = s.collectionConfigs[collection];
        require(!cfg.registered, "StakingLib: already reg");
        require(declaredSupply > 0 && declaredSupply <= 20000, "StakingLib: bad supply");
        cfg.declaredSupply = declaredSupply;
        cfg.registered = true;
        cfg.totalStaked = 0;
        cfg.totalStakers = 0;
    }

    function recordTermStake(
        Storage storage s,
        address collection,
        address staker,
        uint256 tokenId,
        uint256 currentBlock,
        uint256 termDurationBlocks,
        uint256 rewardRateIncrementPerNFT
    ) internal {
        require(staker != address(0), "StakingLib: zero staker");
        require(s.totalStakedAll + 1 <= GLOBAL_CAP, "CATA: global cap reached");
        require(s.totalStakedTerm + 1 <= TERM_CAP, "CATA: term cap reached");

        CollectionConfig storage cfg = s.collectionConfigs[collection];
        require(cfg.registered, "StakingLib: not reg");

        StakeInfo storage info = s.stakeLog[collection][staker][tokenId];
        require(!info.currentlyStaked, "StakingLib: already staked");

        info.stakeBlock = currentBlock;
        info.lastHarvestBlock = currentBlock;
        info.currentlyStaked = true;
        info.isPermanent = false;
        info.unstakeDeadlineBlock = currentBlock + termDurationBlocks;

        if (s.stakePortfolioByUser[collection][staker].length == 0) cfg.totalStakers += 1;
        cfg.totalStaked += 1;

        s.totalStakedNFTsCount += 1;
        s.baseRewardRate += rewardRateIncrementPerNFT;

        s.stakePortfolioByUser[collection][staker].push(tokenId);
        s.indexOfTokenIdInStakePortfolio[collection][tokenId] =
            s.stakePortfolioByUser[collection][staker].length - 1;

        s.totalStakedAll += 1;
        s.totalStakedTerm += 1;

        emit InternalStakeRecorded(staker, collection, tokenId);
    }

    function recordPermanentStake(
        Storage storage s,
        address collection,
        address staker,
        uint256 tokenId,
        uint256 currentBlock,
        uint256 rewardRateIncrementPerNFT
    ) internal {
        require(staker != address(0), "StakingLib: zero staker");
        require(s.totalStakedAll + 1 <= GLOBAL_CAP, "CATA: global cap reached");
        require(s.totalStakedPermanent + 1 <= PERM_CAP, "CATA: perm cap reached");

        CollectionConfig storage cfg = s.collectionConfigs[collection];
        require(cfg.registered, "StakingLib: not reg");

        StakeInfo storage info = s.stakeLog[collection][staker][tokenId];
        require(!info.currentlyStaked, "StakingLib: already staked");

        info.stakeBlock = currentBlock;
        info.lastHarvestBlock = currentBlock;
        info.currentlyStaked = true;
        info.isPermanent = true;
        info.unstakeDeadlineBlock = 0;

        if (s.stakePortfolioByUser[collection][staker].length == 0) cfg.totalStakers += 1;
        cfg.totalStaked += 1;

        s.totalStakedNFTsCount += 1;
        s.baseRewardRate += rewardRateIncrementPerNFT;

        s.stakePortfolioByUser[collection][staker].push(tokenId);
        s.indexOfTokenIdInStakePortfolio[collection][tokenId] =
            s.stakePortfolioByUser[collection][staker].length - 1;

        s.totalStakedAll += 1;
        s.totalStakedPermanent += 1;

        emit InternalStakeRecorded(staker, collection, tokenId);
    }

    function recordUnstake(
        Storage storage s,
        address collection,
        address staker,
        uint256 tokenId,
        uint256 rewardRateIncrementPerNFT
    ) internal {
        StakeInfo storage info = s.stakeLog[collection][staker][tokenId];
        require(info.currentlyStaked, "StakingLib: not staked");

        bool wasPermanent = info.isPermanent;
        info.currentlyStaked = false;

        uint256[] storage port = s.stakePortfolioByUser[collection][staker];
        uint256 idx = s.indexOfTokenIdInStakePortfolio[collection][tokenId];
        uint256 last = port.length - 1;
        if (idx != last) {
            uint256 lastTokenId = port[last];
            port[idx] = lastTokenId;
            s.indexOfTokenIdInStakePortfolio[collection][lastTokenId] = idx;
        }
        port.pop();
        delete s.indexOfTokenIdInStakePortfolio[collection][tokenId];

        CollectionConfig storage cfg = s.collectionConfigs[collection];
        if (port.length == 0 && cfg.totalStakers > 0) cfg.totalStakers -= 1;
        if (cfg.totalStaked > 0) cfg.totalStaked -= 1;

        if (s.baseRewardRate >= rewardRateIncrementPerNFT) s.baseRewardRate -= rewardRateIncrementPerNFT;
        if (s.totalStakedNFTsCount > 0) s.totalStakedNFTsCount -= 1;

        s.totalStakedAll -= 1;
        if (wasPermanent) {
            s.totalStakedPermanent -= 1;
        } else {
            s.totalStakedTerm -= 1;
        }

        emit InternalUnstakeRecorded(staker, collection, tokenId);
    }

    function pendingRewards(
        Storage storage s,
        address collection,
        address owner,
        uint256 tokenId,
        uint256 numberOfBlocksPerRewardUnit
    ) internal view returns (uint256) {
        StakeInfo memory info = s.stakeLog[collection][owner][tokenId];
        if (!info.currentlyStaked || s.baseRewardRate == 0 || s.totalStakedNFTsCount == 0) return 0;
        if (!info.isPermanent && block.number >= info.unstakeDeadlineBlock) return 0;

        uint256 blocksPassed = block.number - info.lastHarvestBlock;
        if (blocksPassed == 0) return 0;
        uint256 numerator = blocksPassed * s.baseRewardRate;
        uint256 rewardAmount = (numerator / numberOfBlocksPerRewardUnit) / s.totalStakedNFTsCount;
        return rewardAmount;
    }

    function updateLastHarvest(Storage storage s, address collection, address owner, uint256 tokenId) internal {
        StakeInfo storage info = s.stakeLog[collection][owner][tokenId];
        info.lastHarvestBlock = block.number;
    }
}

/* ──────────────────────────────────────────────────────────────
   GovernanceLib
─────────────────────────────────────────────────────────────── */
library GovernanceLib {
    enum ProposalType {
        BASE_REWARD,
        HARVEST_FEE,
        UNSTAKE_FEE,
        REGISTRATION_FEE_FALLBACK,
        VOTING_PARAM,
        TIER_UPGRADE
    }

    struct Proposal {
        ProposalType pType;
        uint8 paramTarget;
        uint256 newValue;
        address collectionAddress;
        address proposer;
        uint256 startBlock;
        uint256 endBlock;
        uint256 votesScaled;
        bool executed;
    }

    struct Storage {
        mapping(bytes32 => Proposal) proposals;
        mapping(bytes32 => mapping(address => bool)) hasVoted;
        mapping(bytes32 => mapping(address => uint256)) proposalCollectionVotesScaled;
        uint256 votingDurationBlocks;
        uint256 minVotesRequiredScaled;
        uint256 collectionVoteCapPercent;
    }

    event ProposalCreated(
        bytes32 indexed id,
        ProposalType pType,
        uint8 paramTarget,
        address indexed collection,
        address indexed proposer,
        uint256 newValue,
        uint256 startBlock,
        uint256 endBlock
    );
    event VoteCast(bytes32 indexed id, address indexed voter, uint256 weightScaled, address attributedCollection);
    event ProposalMarkedExecuted(bytes32 indexed id);

    function initGov(
        Storage storage g,
        uint256 votingDurationBlocks_,
        uint256 minVotesRequiredScaled_,
        uint256 collectionVoteCapPercent_
    ) internal {
        require(collectionVoteCapPercent_ <= 100, "GovernanceLib: cap>100");
        g.votingDurationBlocks = votingDurationBlocks_;
        g.minVotesRequiredScaled = minVotesRequiredScaled_;
        g.collectionVoteCapPercent = collectionVoteCapPercent_;
    }

    function createProposal(
        Storage storage g,
        ProposalType pType,
        uint8 paramTarget,
        uint256 newValue,
        address collection,
        address proposer,
        uint256 currentBlock
    ) internal returns (bytes32) {
        bytes32 id = keccak256(
            abi.encodePacked(uint256(pType), paramTarget, newValue, collection, currentBlock, proposer)
        );
        Proposal storage p = g.proposals[id];
        require(p.startBlock == 0, "GovernanceLib: exists");

        p.pType = pType;
        p.paramTarget = paramTarget;
        p.newValue = newValue;
        p.collectionAddress = collection;
        p.proposer = proposer;
        p.startBlock = currentBlock;
        p.endBlock = currentBlock + g.votingDurationBlocks;
        p.votesScaled = 0;
        p.executed = false;

        emit ProposalCreated(id, pType, paramTarget, collection, proposer, newValue, p.startBlock, p.endBlock);
        return id;
    }

    function castVote(
        Storage storage g,
        bytes32 id,
        address voter,
        uint256 weightScaled,
        address attributedCollection
    ) internal {
        Proposal storage p = g.proposals[id];
        require(p.startBlock != 0, "GovernanceLib: not found");
        require(block.number >= p.startBlock && block.number <= p.endBlock, "GovernanceLib: closed");
        require(!p.executed, "GovernanceLib: executed");
        require(!g.hasVoted[id][voter], "GovernanceLib: voted");
        require(weightScaled > 0, "GovernanceLib: zero weight");

        uint256 cap = (g.minVotesRequiredScaled * g.collectionVoteCapPercent) / 100;
        uint256 cur = g.proposalCollectionVotesScaled[id][attributedCollection];
        require(cur + weightScaled <= cap, "GovernanceLib: cap");

        g.hasVoted[id][voter] = true;
        p.votesScaled += weightScaled;
        g.proposalCollectionVotesScaled[id][attributedCollection] = cur + weightScaled;

        emit VoteCast(id, voter, weightScaled, attributedCollection);
    }

    function validateForExecution(Storage storage g, bytes32 id) internal view returns (Proposal memory) {
        Proposal memory p = g.proposals[id];
        require(p.startBlock != 0, "GovernanceLib: not found");
        require(block.number > p.endBlock, "GovernanceLib: voting");
        require(!p.executed, "GovernanceLib: executed");
        require(p.votesScaled >= g.minVotesRequiredScaled, "GovernanceLib: quorum");
        return p;
    }

    function markExecuted(Storage storage g, bytes32 id) internal {
        g.proposals[id].executed = true;
        emit ProposalMarkedExecuted(id);
    }
}

/* ──────────────────────────────────────────────────────────────
   BluechipLib
─────────────────────────────────────────────────────────────── */
library BluechipLib {
    struct WalletEnrollment {
        bool enrolled;
        uint256 lastHarvestBlock;
    }

    struct Storage {
        mapping(address => mapping(address => WalletEnrollment)) bluechipWallets;
        mapping(address => bool) isBluechipCollection; 
        uint256 bluechipWalletFee;
    }

    function enroll(
        Storage storage b,
        address collection,
        address wallet,
        uint256 blockNum,
        uint256 fee,
        function(address,uint256) internal feeHandler
    ) internal {
        WalletEnrollment storage we = b.bluechipWallets[collection][wallet];
        require(!we.enrolled, "Already enrolled");

        if (fee > 0) {
            feeHandler(wallet, fee);
        }

        we.enrolled = true;
        we.lastHarvestBlock = blockNum;
    }

    function harvest(
        Storage storage b,
        address collection,
        address wallet,
        uint256 blockNum,
        uint256 baseRewardRate,
        uint256 blocksPerRewardUnit,
        function(address,uint256) internal mintReward
    ) internal {
        WalletEnrollment storage we = b.bluechipWallets[collection][wallet];
        require(we.enrolled, "Not enrolled");

        uint256 blocksElapsed = blockNum - we.lastHarvestBlock;
        uint256 reward = (blocksElapsed * baseRewardRate) / blocksPerRewardUnit;

        if (reward > 0) {
            mintReward(wallet, reward);
        }

        we.lastHarvestBlock = blockNum;
    }
}

/* ──────────────────────────────────────────────────────────────
   CatalystNFTStakingUpgradeable
─────────────────────────────────────────────────────────────── */

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

