{
  "language": "Solidity",
  "sources": {
    "contracts/Updated.CatalystNFTStakingUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./StakingLib.sol";
import "./GovernanceLib.sol";
import "./BluechipLib.sol";
import "./GuardianLib.sol";

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

contract CatalystNFTStakingUpgradeable is
    Initializable,
    UUPSUpgradeable,
    ERC20Upgradeable,
    AccessControlUpgradeable,
    ReentrancyGuardUpgradeable,
    PausableUpgradeable,
    IERC721Receiver
{
    using StakingLib for StakingLib.Storage;
    using GovernanceLib for GovernanceLib.Storage;
    using BluechipLib for BluechipLib.Storage;
    using GuardianLib for GuardianLib.Storage;

    // -------- Errors --------
    error ZeroAddress();
    error BadParam();
    error NotRegistered();
    error AlreadyExists();
    error NotStaked();
    error TermNotExpired();
    error Cooldown();
    error BatchTooLarge();
    error Ineligible();
    error Unauthorized();
    error NoRequest();
    error Expired();
    error AlreadyApproved();
    error Threshold();
    error Insufficient();
    error AlreadyEnrolled();
    error DuplicateGuardian();
    error NotTheOwner();
    error NoToken();

    // -------- Roles --------
    bytes32 public constant CONTRACT_ADMIN_ROLE = keccak256("CONTRACT_ADMIN_ROLE");

    // -------- Constants & caps --------
    uint256 public constant BURN_BP = 9000;
    uint256 public constant TREASURY_BP = 900;
    uint256 public constant DEPLOYER_BP = 100;
    uint256 public constant BP_DENOM = 10000;

    uint256 public constant GLOBAL_CAP = StakingLib.GLOBAL_CAP;
    uint256 public constant TERM_CAP = StakingLib.TERM_CAP;
    uint256 public constant PERM_CAP = StakingLib.PERM_CAP;

    uint256 public constant MAX_HARVEST_BATCH = 50;
    uint256 public constant MAX_STAKE_PER_COLLECTION = 20_000;
    uint256 public constant WEIGHT_SCALE = 1e18;

    uint256 public constant RECOVERY_WINDOW = 3 days;

    // -------- Library storage --------
    StakingLib.Storage internal s;
    GovernanceLib.Storage internal g;
    BluechipLib.Storage internal b;
    GuardianLib.Storage internal gu; // New storage for GuardianLib

    // -------- Protocol params --------
    uint256 public numberOfBlocksPerRewardUnit;
    uint256 public termDurationBlocks;
    uint256 public stakingCooldownBlocks;
    uint256 public rewardRateIncrementPerNFT;
    uint256 public initialHarvestBurnFeeRate;
    uint256 public unstakeBurnFee;
    uint256 public collectionRegistrationFee;
    address public treasuryAddress;
    address public deployerAddress;
    uint256 public treasuryBalance;
    uint256 public minStakeAgeForVoting;
    uint256 public maxBaseRewardRate;
    address[] public registeredCollections;
    mapping(address => uint256) public registeredIndex;
    mapping(address => uint256) public burnedCatalystByAddress;
    mapping(address => uint256) public lastStakingBlock;

    // -------- Events (kept) --------
    event CollectionTierUpgraded(address indexed collection, StakingLib.Tier newTier);
    event BluechipCollectionSet(address indexed collection, bool isBluechip);
    event CollectionAdded(address indexed collection, uint256 declaredSupply, uint256 paid);
    event NFTStaked(address indexed owner, address indexed collection, uint256 indexed tokenId, bool permanent);
    event NFTUnstaked(address indexed owner, address indexed collection, uint256 indexed tokenId);
    event RewardsHarvested(address indexed owner, address indexed collection, uint256 gross, uint256 burned);
    event TreasuryDeposit(address indexed from, uint256 amount);
    event TreasuryWithdrawal(address indexed to, uint256 amount);

    event BaseRewardRateUpdated(uint256 oldValue, uint256 newValue);
    event HarvestFeeUpdated(uint256 oldValue, uint256 newValue);
    event UnstakeFeeUpdated(uint256 oldValue, uint256 newValue);
    event RegistrationFeeUpdated(uint256 oldValue, uint256 newValue);
    event VotingParamUpdated(uint8 target, uint256 oldValue, uint256 newValue);
    event ProposalExecuted(bytes32 indexed id, uint256 appliedValue);
    event DeployerRecovered(address indexed oldDeployer, address indexed newDeployer);
    event AdminRecovered(address indexed newAdmin);

    // -------- Initializer --------
    struct InitConfig {
        address owner;
        uint256 rewardRateIncrementPerNFT;
        uint256 initialHarvestBurnFeeRate;
        uint256 unstakeBurnFee;
        uint256 termDurationBlocks;
        uint256 numberOfBlocksPerRewardUnit;
        uint256 collectionRegistrationFee;
        uint256 stakingCooldownBlocks;
        uint256 votingDurationBlocks;
        uint256 minVotesRequiredScaled;
        uint256 collectionVoteCapPercent;
        uint256 minStakeAgeForVoting;
        uint256 maxBaseRewardRate;
        address[] deployerGuardians;
        uint256 deployerThreshold;
        address[] adminGuardians;
        uint256 adminThreshold;
        uint256 bluechipWalletFee;
    }

    function initialize(InitConfig calldata cfg) external initializer {
        if (cfg.owner == address(0)) revert ZeroAddress();

        __ERC20_init("Catalyst", "CATA");
        __AccessControl_init();
        __UUPSUpgradeable_init();
        __ReentrancyGuard_init();
        __Pausable_init();

        _grantRole(DEFAULT_ADMIN_ROLE, cfg.owner);
        _grantRole(CONTRACT_ADMIN_ROLE, cfg.owner);

        deployerAddress = cfg.owner;
        treasuryAddress = address(this);
        rewardRateIncrementPerNFT = cfg.rewardRateIncrementPerNFT;
        initialHarvestBurnFeeRate = cfg.initialHarvestBurnFeeRate;
        unstakeBurnFee = cfg.unstakeBurnFee;
        termDurationBlocks = cfg.termDurationBlocks;
        numberOfBlocksPerRewardUnit = cfg.numberOfBlocksPerRewardUnit;
        collectionRegistrationFee = cfg.collectionRegistrationFee;
        stakingCooldownBlocks = cfg.stakingCooldownBlocks;
        minStakeAgeForVoting = cfg.minStakeAgeForVoting;
        maxBaseRewardRate = cfg.maxBaseRewardRate == 0 ? type(uint256).max : cfg.maxBaseRewardRate;

        GovernanceLib.initGov(
            g,
            cfg.votingDurationBlocks,
            cfg.minVotesRequiredScaled,
            cfg.collectionVoteCapPercent
        );
        
        gu.init(
            cfg.deployerGuardians,
            cfg.deployerThreshold,
            cfg.adminGuardians,
            cfg.adminThreshold
        );

        b.bluechipWalletFee = cfg.bluechipWalletFee;
        _mint(cfg.owner, 100_000_000 * 1e18);
    }
    
    // -------- Modifiers --------
    modifier onlyAdmin() {
        if (_msgSender() != deployerAddress && !hasRole(DEFAULT_ADMIN_ROLE, _msgSender())) revert Unauthorized();
        _;
    }

    modifier onlyRegistered(address collection) {
        if (!s.collectionConfigs[collection].registered) revert NotRegistered();
        _;
    }

    modifier onlyContractAdmin() {
        if (!hasRole(CONTRACT_ADMIN_ROLE, _msgSender())) revert Unauthorized();
        _;
    }

    modifier onlyDeployerGuardian() {
        if (!gu.isGuardian(GuardianLib.DEPLOYER_COUNCIL_ID, _msgSender())) revert Unauthorized();
        _;
    }

    modifier onlyAdminGuardian() {
        if (!gu.isGuardian(GuardianLib.ADMIN_COUNCIL_ID, _msgSender())) revert Unauthorized();
        _;
    }

    // -------- Guardians: admin setters --------
    function setDeployerGuardian(uint8 idx, address guardian) external onlyRole(DEFAULT_ADMIN_ROLE) {
        gu.setGuardian(GuardianLib.DEPLOYER_COUNCIL_ID, idx, guardian);
    }

    function setAdminGuardian(uint8 idx, address guardian) external onlyRole(DEFAULT_ADMIN_ROLE) {
        gu.setGuardian(GuardianLib.ADMIN_COUNCIL_ID, idx, guardian);
    }

    // -------- Deployer recovery --------
    function proposeDeployerRecovery(address newDeployer) external whenNotPaused onlyDeployerGuardian {
        gu.proposeRecovery(GuardianLib.DEPLOYER_COUNCIL_ID, newDeployer, RECOVERY_WINDOW, _msgSender());
    }

    function approveDeployerRecovery() external whenNotPaused onlyDeployerGuardian {
        if (gu.approveRecovery(GuardianLib.DEPLOYER_COUNCIL_ID, _msgSender()) < gu.deployerCouncil.threshold) {
            revert Threshold();
        }
    }

    function executeDeployerRecovery() external whenNotPaused {
        address old = deployerAddress;
        address newDeployer = gu.executeRecovery(GuardianLib.DEPLOYER_COUNCIL_ID);
        deployerAddress = newDeployer;
        emit DeployerRecovered(old, newDeployer);
    }

    // -------- Admin recovery --------
    function proposeAdminRecovery(address newAdmin) external whenNotPaused onlyAdminGuardian {
        gu.proposeRecovery(GuardianLib.ADMIN_COUNCIL_ID, newAdmin, RECOVERY_WINDOW, _msgSender());
    }

    function approveAdminRecovery() external whenNotPaused onlyAdminGuardian {
        if (gu.approveRecovery(GuardianLib.ADMIN_COUNCIL_ID, _msgSender()) < gu.adminCouncil.threshold) {
            revert Threshold();
        }
    }

    function executeAdminRecovery() external whenNotPaused onlyRole(DEFAULT_ADMIN_ROLE) {
        address newAdmin = gu.executeRecovery(GuardianLib.ADMIN_COUNCIL_ID);
        _grantRole(DEFAULT_ADMIN_ROLE, newAdmin);
        emit AdminRecovered(newAdmin);
    }

    // -------- Registration (permissionless with fee guard) --------
function registerCollection(address collection, uint256 declaredMaxSupply) external whenNotPaused nonReentrant {
        if (collection == address(0)) revert ZeroAddress();
        if (registeredIndex[collection] != 0) revert AlreadyExists();
        if (declaredMaxSupply == 0 || declaredMaxSupply > MAX_STAKE_PER_COLLECTION) revert BadParam();

        uint256 fee = collectionRegistrationFee;
        if (fee > 0) _splitFeeFromSender(_msgSender(), fee);

        s.initCollection(collection, declaredMaxSupply);
        registeredCollections.push(collection);
        registeredIndex[collection] = registeredCollections.length;

        emit CollectionAdded(collection, declaredMaxSupply, fee);
    }

function isCollectionRegistered(address collection) external view returns (bool) {
    return s.collectionConfigs[collection].registered;
}

   // -------- Custodial Staking --------
    modifier notInCooldown() {
        if (block.number < lastStakingBlock[_msgSender()] + stakingCooldownBlocks) revert Cooldown();
        _;
    }

    function stake(address collection, uint256 tokenId, bool permanent)
        public
        whenNotPaused
        nonReentrant
        notInCooldown
    {
        if (collection == address(0)) revert ZeroAddress();
        if (!s.collectionConfigs[collection].registered) revert NotRegistered();
        if (s.stakeLog[collection][_msgSender()][tokenId].currentlyStaked) revert AlreadyExists();
        
        // transfer NFT (requires approval)
        IERC721(collection).safeTransferFrom(_msgSender(), address(this), tokenId);

        if (permanent) {
            s.recordPermanentStake(
                collection,
                _msgSender(),
                tokenId,
                block.number,
                rewardRateIncrementPerNFT
            );
        } else {
            s.recordTermStake(
                collection,
                _msgSender(),
                tokenId,
                block.number,
                termDurationBlocks,
                rewardRateIncrementPerNFT
            );
        }

        // ✅ increment per-collection counter
        s.collectionTotalStaked[collection] += 1;

        lastStakingBlock[_msgSender()] = block.number;
        emit NFTStaked(_msgSender(), collection, tokenId, permanent);
    }

    function batchStake(address collection, uint256[] calldata tokenIds, bool permanent) external whenNotPaused nonReentrant {
        uint256 n = tokenIds.length;
        if (n == 0 || n > MAX_HARVEST_BATCH) revert BatchTooLarge();
        for (uint256 i = 0; i < n; ++i) {
            stake(collection, tokenIds[i], permanent);
        }
    }

    function _pendingRewardInternal(address collection, address owner, uint256 tokenId) internal view returns (uint256) {
        return s.pendingRewards(collection, owner, tokenId, numberOfBlocksPerRewardUnit);
    }

    function harvest(address collection, uint256 tokenId) public whenNotPaused nonReentrant {
        StakingLib.StakeInfo storage si = s.stakeLog[collection][_msgSender()][tokenId];
        if (!si.currentlyStaked) revert NotStaked();

        uint256 reward = _pendingRewardInternal(collection, _msgSender(), tokenId);
        if (reward == 0) return;

        uint256 harvestBurnFee = initialHarvestBurnFeeRate;
        uint256 burnAmt = (reward * harvestBurnFee) / BP_DENOM;
        uint256 mintAmount = reward - burnAmt;

        _mint(_msgSender(), mintAmount);
        if (burnAmt > 0) {
            _burn(_msgSender(), burnAmt);
            burnedCatalystByAddress[_msgSender()] += burnAmt;
        }
        s.updateLastHarvest(collection, _msgSender(), tokenId);
        emit RewardsHarvested(_msgSender(), collection, mintAmount, burnAmt);
    }
    
    function harvestBatch(address collection, uint256[] calldata tokenIds) external whenNotPaused nonReentrant {
        uint256 n = tokenIds.length;
        if (n == 0 || n > 200) revert BadParam(); // safety cap for front-end
        for (uint256 i = 0; i < n; ++i) {
            harvest(collection, tokenIds[i]);
        }
    }

    function unstake(address collection, uint256 tokenId) public whenNotPaused nonReentrant {
        StakingLib.StakeInfo memory info = s.stakeLog[collection][_msgSender()][tokenId];
        if (!info.currentlyStaked) revert NotStaked();
        if (!info.isPermanent && block.number < info.unstakeDeadlineBlock) revert TermNotExpired();

        // harvest pending
        uint256 reward = _pendingRewardInternal(collection, _msgSender(), tokenId);
        if (reward > 0) {
            uint256 harvestBurnFee = initialHarvestBurnFeeRate;
            uint256 burnAmt = (reward * harvestBurnFee) / BP_DENOM;
            uint256 mintAmount = reward - burnAmt;
            _mint(_msgSender(), mintAmount);
            if (burnAmt > 0) {
                _burn(_msgSender(), burnAmt);
                burnedCatalystByAddress[_msgSender()] += burnAmt;
            }
            s.updateLastHarvest(collection, _msgSender(), tokenId);
            emit RewardsHarvested(_msgSender(), collection, mintAmount, burnAmt);
        }

        if (unstakeBurnFee > 0) {
            if (balanceOf(_msgSender()) < unstakeBurnFee) revert Insufficient();
            _burn(_msgSender(), unstakeBurnFee);
            burnedCatalystByAddress[_msgSender()] += unstakeBurnFee;
        }

        s.recordUnstake(collection, _msgSender(), tokenId, rewardRateIncrementPerNFT);

// ✅ decrement counter
        if (s.collectionTotalStaked[collection] > 0) {
            s.collectionTotalStaked[collection] -= 1;
        }

        // transfer NFT back
        IERC721(collection).safeTransferFrom(address(this), _msgSender(), tokenId);
        emit NFTUnstaked(_msgSender(), collection, tokenId);
    }

    function unstakeBatch(address collection, uint256[] calldata tokenIds) external whenNotPaused nonReentrant {
        uint256 n = tokenIds.length;
        if (n == 0 || n > 200) revert BadParam();
        for (uint256 i = 0; i < n; ++i) {
            unstake(collection, tokenIds[i]);
        }
    }


    // -------- Blue-chip (non-custodial) --------
    function setBluechipCollection(address collection, bool isBluechip)
        external
        onlyRole(CONTRACT_ADMIN_ROLE)
        whenNotPaused
        onlyRegistered(collection)
    {
        b.isBluechipCollection[collection] = isBluechip;
        emit BluechipCollectionSet(collection, isBluechip); // ✅ now works
    }

    function enrollBluechip() external whenNotPaused nonReentrant {
        address wallet = _msgSender();
        // check already enrolled global slot
        if (b.bluechipWallets[address(0)][wallet].enrolled) revert AlreadyEnrolled();
        uint256 fee = b.bluechipWalletFee;
        // fee splitter will revert if insufficient balance
        BluechipLib.enroll(b, address(0), wallet, block.number, fee, _splitFeeFromSender);
    }

    function harvestBluechip(address collection) external whenNotPaused nonReentrant {
        if (!b.isBluechipCollection[collection]) revert Ineligible();
        if (IERC721(collection).balanceOf(_msgSender()) == 0) revert NoToken();
        // compute reward (simple model: use baseRewardRate & blocks since last enrollment/harvest)
        // For simplicity use baseRewardRate / total staked as approximation (same as custodial)
        // main contract retains mint logic and bookkeeping for bluechip harvests if required
        // Here we delegate to BluechipLib for checks, then mint externally:
        BluechipLib.harvest(b, collection, _msgSender(), block.number, s.baseRewardRate, numberOfBlocksPerRewardUnit, _mintReward);
        // Note: ensure BluechipLib.harvest triggers appropriate mint or inform main contract to mint
    }

    // -------- Governance wrappers --------
    function propose(
        GovernanceLib.ProposalType pType,
        uint8 paramTarget,
        uint256 newValue,
        address collectionContext
    ) external whenNotPaused returns (bytes32) {
        (uint256 weight,) = _votingWeight(_msgSender());
        if (weight == 0) revert Ineligible();

        return GovernanceLib.createProposal(
            g,
            pType,
            paramTarget,
            newValue,
            collectionContext,
            _msgSender(),
            block.number
        );
    }

    function vote(bytes32 id) external whenNotPaused {
        (uint256 weight, address attributedCollection) = _votingWeight(_msgSender());
        if (weight == 0) revert Ineligible();
        GovernanceLib.castVote(g, id, _msgSender(), weight, attributedCollection);
    }

    function executeProposal(bytes32 id) external whenNotPaused nonReentrant {
        GovernanceLib.Proposal memory p = GovernanceLib.validateForExecution(g, id);
        GovernanceLib.markExecuted(g, id);

        if (p.pType == GovernanceLib.ProposalType.BASE_REWARD) {
            uint256 old = s.baseRewardRate;
            s.baseRewardRate = p.newValue > maxBaseRewardRate ? maxBaseRewardRate : p.newValue;
            emit BaseRewardRateUpdated(old, s.baseRewardRate);
        } else if (p.pType == GovernanceLib.ProposalType.HARVEST_FEE) {
            uint256 old = initialHarvestBurnFeeRate;
            initialHarvestBurnFeeRate = p.newValue; // expect 0..100
            emit HarvestFeeUpdated(old, p.newValue);
        } else if (p.pType == GovernanceLib.ProposalType.UNSTAKE_FEE) {
            uint256 old = unstakeBurnFee;
            unstakeBurnFee = p.newValue;
            emit UnstakeFeeUpdated(old, p.newValue);
        } else if (p.pType == GovernanceLib.ProposalType.REGISTRATION_FEE_FALLBACK) {
            uint256 old = collectionRegistrationFee;
            collectionRegistrationFee = p.newValue;
            emit RegistrationFeeUpdated(old, p.newValue);
        } else if (p.pType == GovernanceLib.ProposalType.VOTING_PARAM) {
            uint8 t = p.paramTarget;
            if (t == 0) { uint256 old = g.minVotesRequiredScaled; g.minVotesRequiredScaled = p.newValue; emit VotingParamUpdated(t, old, p.newValue); }
            else if (t == 1) { uint256 old = g.votingDurationBlocks; g.votingDurationBlocks = p.newValue; emit VotingParamUpdated(t, old, p.newValue); }
            else if (t == 2) { uint256 old = g.collectionVoteCapPercent"
    },
    "contracts/StakingLib.sol": {
      "content": "// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";

/// @notice Lightweight staking library (bookkeeping only).
library StakingLib {
    // Staking caps declared at the library level
    uint256 public constant GLOBAL_CAP = 1_000_000_000;
    uint256 public constant TERM_CAP = 750_000_000;
    uint256 public constant PERM_CAP = 250_000_000;

    struct StakeInfo {
        uint256 stakeBlock;
        uint256 lastHarvestBlock;
        bool currentlyStaked;
        bool isPermanent;
        uint256 unstakeDeadlineBlock;
    }

    enum Tier {
        NONE,
        UNVERIFIED,
        VERIFIED,
        BLUECHIP
    }

    struct CollectionConfig {
        uint256 totalStaked;
        uint256 totalStakers;
        bool registered;
        uint256 declaredSupply;
        Tier tier;
    }

    struct Storage {
        // Counters for staked NFTs
        uint256 totalStakedAll;
        uint256 totalStakedTerm;
        uint256 totalStakedPermanent;

        mapping(address => uint256) collectionTotalStaked;
        mapping(address => CollectionConfig) collectionConfigs;
        mapping(address => mapping(address => mapping(uint256 => StakeInfo))) stakeLog;
        mapping(address => mapping(address => uint256[])) stakePortfolioByUser;
        mapping(address => mapping(uint256 => uint256)) indexOfTokenIdInStakePortfolio;
        uint256 totalStakedNFTsCount;
        uint256 baseRewardRate;
uint256 maxSupply;
address admin;
    }

    event InternalStakeRecorded(address indexed owner, address indexed collection, uint256 indexed tokenId);
    event InternalUnstakeRecorded(address indexed owner, address indexed collection, uint256 indexed tokenId);

    // 👈 Add this line to declare the event
    event CollectionRegistered(address indexed collection, address indexed registerer, Tier tier, uint256 declaredSupply);

    function initCollection(Storage storage s, address collection, uint256 declaredSupply) internal {
        require(collection != address(0), "StakingLib: zero address");
        CollectionConfig storage cfg = s.collectionConfigs[collection];
        require(!cfg.registered, "StakingLib: already registered");
        require(declaredSupply > 0 && declaredSupply <= s.maxSupply, "StakingLib: invalid supply");

        cfg.registered = true;
        cfg.declaredSupply = declaredSupply;
        cfg.totalStaked = 0;
        cfg.totalStakers = 0;

        // Determine tier based on caller identity
        bool isVerified = false;
        try Ownable(collection).owner() returns (address owner) {
            if (owner == msg.sender) {
                isVerified = true;
            }
        } catch {
            // If collection is not Ownable, leave isVerified = false
        }

        if (msg.sender == s.admin || isVerified) {
            cfg.tier = Tier.VERIFIED;
        } else {
            cfg.tier = Tier.UNVERIFIED;
        }

        emit CollectionRegistered(collection, msg.sender, cfg.tier, declaredSupply);
    }

    function recordTermStake(
        Storage storage s,
        address collection,
        address staker,
        uint256 tokenId,
        uint256 currentBlock,
        uint256 termDurationBlocks,
        uint256 rewardRateIncrementPerNFT
    ) internal {
        require(staker != address(0), "StakingLib: zero staker");
        // Cap checks for term staking using the constants
        require(s.totalStakedAll + 1 <= GLOBAL_CAP, "CATA: global cap reached");
        require(s.totalStakedTerm + 1 <= TERM_CAP, "CATA: term cap reached");

        CollectionConfig storage cfg = s.collectionConfigs[collection];
        require(cfg.registered, "StakingLib: not reg");

        StakeInfo storage info = s.stakeLog[collection][staker][tokenId];
        require(!info.currentlyStaked, "StakingLib: already staked");

        info.stakeBlock = currentBlock;
        info.lastHarvestBlock = currentBlock;
        info.currentlyStaked = true;
        info.isPermanent = false;
        info.unstakeDeadlineBlock = currentBlock + termDurationBlocks;

        if (s.stakePortfolioByUser[collection][staker].length == 0) cfg.totalStakers += 1;
        cfg.totalStaked += 1;

        s.totalStakedNFTsCount += 1;
        s.baseRewardRate += rewardRateIncrementPerNFT;

        s.stakePortfolioByUser[collection][staker].push(tokenId);
        s.indexOfTokenIdInStakePortfolio[collection][tokenId] = s.stakePortfolioByUser[collection][staker].length - 1;

        // Increment global counters
        s.totalStakedAll += 1;
        s.totalStakedTerm += 1;

        emit InternalStakeRecorded(staker, collection, tokenId);
    }

    function recordPermanentStake(
        Storage storage s,
        address collection,
        address staker,
        uint256 tokenId,
        uint256 currentBlock,
        uint256 rewardRateIncrementPerNFT
    ) internal {
        require(staker != address(0), "StakingLib: zero staker");
        // Cap checks for permanent staking using the constants
        require(s.totalStakedAll + 1 <= GLOBAL_CAP, "CATA: global cap reached");
        require(s.totalStakedPermanent + 1 <= PERM_CAP, "CATA: perm cap reached");

        CollectionConfig storage cfg = s.collectionConfigs[collection];
        require(cfg.registered, "StakingLib: not reg");

        StakeInfo storage info = s.stakeLog[collection][staker][tokenId];
        require(!info.currentlyStaked, "StakingLib: already staked");

        info.stakeBlock = currentBlock;
        info.lastHarvestBlock = currentBlock;
        info.currentlyStaked = true;
        info.isPermanent = true;
        info.unstakeDeadlineBlock = 0;

        if (s.stakePortfolioByUser[collection][staker].length == 0) cfg.totalStakers += 1;
        cfg.totalStaked += 1;

        s.totalStakedNFTsCount += 1;
        s.baseRewardRate += rewardRateIncrementPerNFT;

        s.stakePortfolioByUser[collection][staker].push(tokenId);
        s.indexOfTokenIdInStakePortfolio[collection][tokenId] = s.stakePortfolioByUser[collection][staker].length - 1;

        // Increment global counters
        s.totalStakedAll += 1;
        s.totalStakedPermanent += 1;

        emit InternalStakeRecorded(staker, collection, tokenId);
    }

    function recordUnstake(
        Storage storage s,
        address collection,
        address staker,
        uint256 tokenId,
        uint256 rewardRateIncrementPerNFT
    ) internal {
        StakeInfo storage info = s.stakeLog[collection][staker][tokenId];
        require(info.currentlyStaked, "StakingLib: not staked");

        // store isPermanent before flipping
        bool wasPermanent = info.isPermanent;

        info.currentlyStaked = false;

        uint256[] storage port = s.stakePortfolioByUser[collection][staker];
        uint256 idx = s.indexOfTokenIdInStakePortfolio[collection][tokenId];
        uint256 last = port.length - 1;
        if (idx != last) {
            uint256 lastTokenId = port[last];
            port[idx] = lastTokenId;
            s.indexOfTokenIdInStakePortfolio[collection][lastTokenId] = idx;
        }
        port.pop();
        delete s.indexOfTokenIdInStakePortfolio[collection][tokenId];

        CollectionConfig storage cfg = s.collectionConfigs[collection];
        if (port.length == 0 && cfg.totalStakers > 0) cfg.totalStakers -= 1;
        if (cfg.totalStaked > 0) cfg.totalStaked -= 1;

        if (s.baseRewardRate >= rewardRateIncrementPerNFT) s.baseRewardRate -= rewardRateIncrementPerNFT;
        if (s.totalStakedNFTsCount > 0) s.totalStakedNFTsCount -= 1;

        // Decrement global counters based on stake type
        s.totalStakedAll -= 1;
        if (wasPermanent) {
            s.totalStakedPermanent -= 1;
        } else {
            s.totalStakedTerm -= 1;
        }

        emit InternalUnstakeRecorded(staker, collection, tokenId);
    }

    function pendingRewards(
        Storage storage s,
        address collection,
        address owner,
        uint256 tokenId,
        uint256 numberOfBlocksPerRewardUnit
    ) internal view returns (uint256) {
        StakeInfo memory info = s.stakeLog[collection][owner][tokenId];
        if (!info.currentlyStaked || s.baseRewardRate == 0 || s.totalStakedNFTsCount == 0) return 0;
        if (!info.isPermanent && block.number >= info.unstakeDeadlineBlock) return 0;

        uint256 blocksPassed = block.number - info.lastHarvestBlock;
        if (blocksPassed == 0) return 0;
        uint256 numerator = blocksPassed * s.baseRewardRate;
        uint256 rewardAmount = (numerator / numberOfBlocksPerRewardUnit) / s.totalStakedNFTsCount;
        return rewardAmount;
    }

    function updateLastHarvest(Storage storage s, address collection, address owner, uint256 tokenId) internal {
        StakeInfo storage info = s.stakeLog[collection][owner][tokenId];
        info.lastHarvestBlock = block.number;
    }

    function sqrt(uint256 y) internal pure returns (uint256 z) {
        if (y > 3) {
            z = y;
            uint256 x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) z = 1;
    }
}"
    },
    "contracts/GovernanceLib.sol": {
      "content": "// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @notice Governance bookkeeping library (create + vote + validate execute).
library GovernanceLib {
    enum ProposalType {
        BASE_REWARD,
        HARVEST_FEE,
        UNSTAKE_FEE,
        REGISTRATION_FEE_FALLBACK,
        VOTING_PARAM,
        TIER_UPGRADE
    }

    struct Proposal {
        ProposalType pType;
        uint8 paramTarget;
        uint256 newValue;
        address collectionAddress;
        address proposer;
        uint256 startBlock;
        uint256 endBlock;
        uint256 votesScaled;
        bool executed;
    }

    struct Storage {
        mapping(bytes32 => Proposal) proposals;
        mapping(bytes32 => mapping(address => bool)) hasVoted;
        mapping(bytes32 => mapping(address => uint256)) proposalCollectionVotesScaled;
        uint256 votingDurationBlocks;
        uint256 minVotesRequiredScaled;
        uint256 collectionVoteCapPercent; // percent 0..100
    }

    event ProposalCreated(
        bytes32 indexed id,
        ProposalType pType,
        uint8 paramTarget,
        address indexed collection,
        address indexed proposer,
        uint256 newValue,
        uint256 startBlock,
        uint256 endBlock
    );
    event VoteCast(bytes32 indexed id, address indexed voter, uint256 weightScaled, address attributedCollection);
    event ProposalMarkedExecuted(bytes32 indexed id);

    function initGov(
        Storage storage g,
        uint256 votingDurationBlocks_,
        uint256 minVotesRequiredScaled_,
        uint256 collectionVoteCapPercent_
    ) internal {
        require(collectionVoteCapPercent_ <= 100, "GovernanceLib: cap>100");
        g.votingDurationBlocks = votingDurationBlocks_;
        g.minVotesRequiredScaled = minVotesRequiredScaled_;
        g.collectionVoteCapPercent = collectionVoteCapPercent_;
    }

    function createProposal(
        Storage storage g,
        ProposalType pType,
        uint8 paramTarget,
        uint256 newValue,
        address collection,
        address proposer,
        uint256 currentBlock
    ) internal returns (bytes32) {
        bytes32 id = keccak256(
            abi.encodePacked(uint256(pType), paramTarget, newValue, collection, currentBlock, proposer)
        );
        Proposal storage p = g.proposals[id];
        require(p.startBlock == 0, "GovernanceLib: exists");

        p.pType = pType;
        p.paramTarget = paramTarget;
        p.newValue = newValue;
        p.collectionAddress = collection;
        p.proposer = proposer;
        p.startBlock = currentBlock;
        p.endBlock = currentBlock + g.votingDurationBlocks;
        p.votesScaled = 0;
        p.executed = false;

        emit ProposalCreated(id, pType, paramTarget, collection, proposer, newValue, p.startBlock, p.endBlock);
        return id;
    }

    function castVote(
        Storage storage g,
        bytes32 id,
        address voter,
        uint256 weightScaled,
        address attributedCollection
    ) internal {
        Proposal storage p = g.proposals[id];
        require(p.startBlock != 0, "GovernanceLib: not found");
        require(block.number >= p.startBlock && block.number <= p.endBlock, "GovernanceLib: closed");
        require(!p.executed, "GovernanceLib: executed");
        require(!g.hasVoted[id][voter], "GovernanceLib: voted");
        require(weightScaled > 0, "GovernanceLib: zero weight");

        uint256 cap = (g.minVotesRequiredScaled * g.collectionVoteCapPercent) / 100;
        uint256 cur = g.proposalCollectionVotesScaled[id][attributedCollection];
        require(cur + weightScaled <= cap, "GovernanceLib: cap");

        g.hasVoted[id][voter] = true;
        p.votesScaled += weightScaled;
        g.proposalCollectionVotesScaled[id][attributedCollection] = cur + weightScaled;

        emit VoteCast(id, voter, weightScaled, attributedCollection);
    }

    /// @notice Validate execution conditions; does not mark executed
    function validateForExecution(Storage storage g, bytes32 id) internal view returns (Proposal memory) {
        Proposal memory p = g.proposals[id];
        require(p.startBlock != 0, "GovernanceLib: not found");
        require(block.number > p.endBlock, "GovernanceLib: voting");
        require(!p.executed, "GovernanceLib: executed");
        require(p.votesScaled >= g.minVotesRequiredScaled, "GovernanceLib: quorum");
        return p;
    }

    /// @notice Mark executed separately
    function markExecuted(Storage storage g, bytes32 id) internal {
        g.proposals[id].executed = true;
        emit ProposalMarkedExecuted(id);
    }
}"
    },
    "contracts/BluechipLib.sol": {
      "content": "// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @notice Blue-chip staking helpers (wallet enrollment + per-collection bookkeeping).
library BluechipLib {
    struct WalletEnrollment {
        bool enrolled;
        uint256 lastHarvestBlock;
    }

    struct Storage {
        // mapping: collection => (wallet => enrollment info)
        mapping(address => mapping(address => WalletEnrollment)) bluechipWallets;
        mapping(address => bool) isBluechipCollection; 
        uint256 bluechipWalletFee;
    }

    function enroll(
        Storage storage b,
        address collection, // can be address(0) for global
        address wallet,
        uint256 blockNum,
        uint256 fee,
        function(address,uint256) internal feeHandler
    ) internal {
        WalletEnrollment storage we = b.bluechipWallets[collection][wallet];
        require(!we.enrolled, "Already enrolled");

        if (fee > 0) {
            feeHandler(wallet, fee);
        }

        we.enrolled = true;
        we.lastHarvestBlock = blockNum;
    }

    function harvest(
        Storage storage b,
        address collection,
        address wallet,
        uint256 blockNum,
        uint256 baseRewardRate,
        uint256 blocksPerRewardUnit,
        function(address,uint256) internal mintReward
    ) internal {
        WalletEnrollment storage we = b.bluechipWallets[collection][wallet];
        require(we.enrolled, "Not enrolled");

        // Example reward logic
        uint256 blocksElapsed = blockNum - we.lastHarvestBlock;
        uint256 reward = (blocksElapsed * baseRewardRate) / blocksPerRewardUnit;

        if (reward > 0) {
            mintReward(wallet, reward);
        }

        we.lastHarvestBlock = blockNum;
    }
}"
    },
    "contracts/GuardianLib.sol": {
      "content": "// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

library GuardianLib {
    // A single, reusable struct for a guardian council
    struct GuardianCouncil {
        address[] guardians;
        mapping(address => bool) isGuardian;
        uint256 threshold;
    }

    // A single, reusable struct for a recovery request
    struct RecoveryRequest {
        address proposed;
        uint8 approvals;
        uint256 deadline;
        bool executed;
    }

    struct Storage {
        GuardianCouncil deployerCouncil;
        GuardianCouncil adminCouncil;
        RecoveryRequest deployerRecovery;
        mapping(address => bool) deployerHasApproved;
        RecoveryRequest adminRecovery;
        mapping(address => bool) adminHasApproved;
    }

    // Errors
    error ZeroAddress();
    error BadParam();
    error DuplicateGuardian();
    error Unauthorized();
    error NoRequest();
    error Expired();
    error AlreadyApproved();
    error ThresholdNotMet();
    error ExistingGuardian();
    error NotAGuardian();

    event GuardianSet(bytes32 indexed councilId, uint8 indexed idx, address guardian);
    event RecoveryProposed(bytes32 indexed councilId, address indexed proposer, address proposed, uint256 deadline);
    event RecoveryApproved(bytes32 indexed councilId, address indexed guardian, uint8 approvals);
    event Recovered(bytes32 indexed councilId, address oldAddress, address newAddress);

    bytes32 public constant DEPLOYER_COUNCIL_ID = keccak256("DEPLOYER");
    bytes32 public constant ADMIN_COUNCIL_ID = keccak256("ADMIN");

    function init(
        Storage storage s,
        address[] memory deployerGuardians,
        uint256 deployerThreshold,
        address[] memory adminGuardians,
        uint256 adminThreshold
    ) internal {
        _setGuardians(s.deployerCouncil, deployerGuardians, deployerThreshold);
        _setGuardians(s.adminCouncil, adminGuardians, adminThreshold);
    }

    function _setGuardians(
        GuardianCouncil storage council,
        address[] memory _guardians,
        uint256 _threshold
    ) private {
        require(_threshold > 0 && _threshold <= _guardians.length, "Invalid threshold");
        for (uint256 i = 0; i < _guardians.length; i++) {
            address g = _guardians[i];
            require(g != address(0), "Zero guardian");
            require(!council.isGuardian[g], "Duplicate guardian");
            council.guardians.push(g);
            council.isGuardian[g] = true;
        }
        council.threshold = _threshold;
    }

    function proposeRecovery(
        Storage storage s,
        bytes32 councilId,
        address newAddress,
        uint256 recoveryWindow,
        address proposer
    ) internal {
        if (newAddress == address(0)) revert ZeroAddress();
        if (councilId == DEPLOYER_COUNCIL_ID) {
            if (!s.deployerCouncil.isGuardian[proposer]) revert Unauthorized();
            s.deployerRecovery = RecoveryRequest({
                proposed: newAddress,
                approvals: 0,
                deadline: block.timestamp + recoveryWindow,
                executed: false
            });
            for (uint256 i = 0; i < s.deployerCouncil.guardians.length; ++i) {
                s.deployerHasApproved[s.deployerCouncil.guardians[i]] = false;
            }
            emit RecoveryProposed(DEPLOYER_COUNCIL_ID, proposer, newAddress, s.deployerRecovery.deadline);
        } else if (councilId == ADMIN_COUNCIL_ID) {
            if (!s.adminCouncil.isGuardian[proposer]) revert Unauthorized();
            s.adminRecovery = RecoveryRequest({
                proposed: newAddress,
                approvals: 0,
                deadline: block.timestamp + recoveryWindow,
                executed: false
            });
            for (uint256 i = 0; i < s.adminCouncil.guardians.length; ++i) {
                s.adminHasApproved[s.adminCouncil.guardians[i]] = false;
            }
            emit RecoveryProposed(ADMIN_COUNCIL_ID, proposer, newAddress, s.adminRecovery.deadline);
        } else {
            revert BadParam();
        }
    }

    function approveRecovery(
        Storage storage s,
        bytes32 councilId,
        address approver
    ) internal returns (uint8) {
        if (councilId == DEPLOYER_COUNCIL_ID) {
            if (!s.deployerCouncil.isGuardian[approver]) revert Unauthorized();
            if (s.deployerRecovery.proposed == address(0)) revert NoRequest();
            if (block.timestamp > s.deployerRecovery.deadline) revert Expired();
            if (s.deployerRecovery.executed) revert AlreadyApproved();
            if (s.deployerHasApproved[approver]) revert AlreadyApproved();

            s.deployerHasApproved[approver] = true;
            s.deployerRecovery.approvals++;
            emit RecoveryApproved(DEPLOYER_COUNCIL_ID, approver, s.deployerRecovery.approvals);
            return s.deployerRecovery.approvals;
        } else if (councilId == ADMIN_COUNCIL_ID) {
            if (!s.adminCouncil.isGuardian[approver]) revert Unauthorized();
            if (s.adminRecovery.proposed == address(0)) revert NoRequest();
            if (block.timestamp > s.adminRecovery.deadline) revert Expired();
            if (s.adminRecovery.executed) revert AlreadyApproved();
            if (s.adminHasApproved[approver]) revert AlreadyApproved();

            s.adminHasApproved[approver] = true;
            s.adminRecovery.approvals++;
            emit RecoveryApproved(ADMIN_COUNCIL_ID, approver, s.adminRecovery.approvals);
            return s.adminRecovery.approvals;
        } else {
            revert BadParam();
        }
    }

    function executeRecovery(
        Storage storage s,
        bytes32 councilId
    ) internal returns (address) {
        if (councilId == DEPLOYER_COUNCIL_ID) {
            if (s.deployerRecovery.proposed == address(0)) revert NoRequest();
            if (block.timestamp > s.deployerRecovery.deadline) revert Expired();
            if (s.deployerRecovery.executed) revert AlreadyApproved();
            if (s.deployerRecovery.approvals < s.deployerCouncil.threshold) revert ThresholdNotMet();

            address old = s.deployerCouncil.guardians[0];
            address newAddress = s.deployerRecovery.proposed;
            s.deployerRecovery.executed = true;

            emit Recovered(DEPLOYER_COUNCIL_ID, old, newAddress);
            return newAddress;
        } else if (councilId == ADMIN_COUNCIL_ID) {
            if (s.adminRecovery.proposed == address(0)) revert NoRequest();
            if (block.timestamp > s.adminRecovery.deadline) revert Expired();
            if (s.adminRecovery.executed) revert AlreadyApproved();
            if (s.adminRecovery.approvals < s.adminCouncil.threshold) revert ThresholdNotMet();
            address newAddress = s.adminRecovery.proposed;
            s.adminRecovery.executed = true;
            emit Recovered(ADMIN_COUNCIL_ID, address(0), newAddress);
            return newAddress;
        } else {
            revert BadParam();
        }
    }

    function isGuardian(Storage storage s, bytes32 councilId, address guardian) internal view returns (bool) {
        if (councilId == DEPLOYER_COUNCIL_ID) {
            return s.deployerCouncil.isGuardian[guardian];
        } else if (councilId == ADMIN_COUNCIL_ID) {
            return s.adminCouncil.isGuardian[guardian];
        } else {
            revert BadParam();
        }
    }

    function setGuardian(
        Storage storage s,
        bytes32 councilId,
        uint8 idx,
        address guardian
    ) internal {
        if (councilId == DEPLOYER_COUNCIL_ID) {
            if (idx >= s.deployerCouncil.guardians.length) revert BadParam();
            if (guardian == address(0)) revert ZeroAddress();
            if (s.deployerCouncil.isGuardian[guardian]) revert DuplicateGuardian();

            address old = s.deployerCouncil.guardians[idx];
            if (old != address(0)) s.deployerCouncil.isGuardian[old] = false;
            s.deployerCouncil.guardians[idx] = guardian;
            s.deployerCouncil.isGuardian[guardian] = true;
            emit GuardianSet(DEPLOYER_COUNCIL_ID, idx, guardian);
        } else if (councilId == ADMIN_COUNCIL_ID) {
            if (idx >= s.adminCouncil.guardians.length) revert BadParam();
            if (guardian == address(0)) revert ZeroAddress();
            if (s.adminCouncil.isGuardian[guardian]) revert DuplicateGuardian();

            address old = s.adminCouncil.guardians[idx];
            if (old != address(0)) s.adminCouncil.isGuardian[old] = false;
            s.adminCouncil.guardians[idx] = guardian;
            s.adminCouncil.isGuardian[guardian] = true;
            emit GuardianSet(ADMIN_COUNCIL_ID, idx, guardian);
        } else {
            revert BadParam();
        }
    }
}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode"
        ]
      }
    },
    "remappings": [
      "@openzeppelin/contracts-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable/",
      "@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/"
    ]
  }
}
