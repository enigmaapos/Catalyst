<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1"
  />
  <title>Catalyst — Official DApp</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Keep your ethers v6 -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.umd.min.js"></script>

  <link rel="icon" href="data:,">
  <style>
    /* --- your original styles left unchanged --- */
    :root{
      --card:#0b1220;
      --ink:#e9eef7;
      --muted:#97a3b6;
      --line:#1b2640;
      --accent:#60a5fa;
      --ok:#22c55e;
      --warn:#f59e0b;
      --err:#ef4444;
    }
    html,body{background:#050b18;color:var(--ink);}
    .glass{background:rgba(12,18,34,.75);backdrop-filter: blur(10px);}
    .ring-1{border:1px solid var(--line);}
    .muted{color:var(--muted)}
    .mono{font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace}
    .btn{border:1px solid var(--line);padding:.6rem .8rem;border-radius:.75rem;display:inline-flex;gap:.5rem;align-items:center}
    .btn-primary{background:#0f172a;border-color:#1f2a49}
    .btn-ghost{background:transparent}
    .btn-danger{background:#1a0e12;border-color:#411826}
    .chip{border:1px solid var(--line);border-radius:.65rem;padding:.25rem .5rem}
    .kbd{border:1px solid var(--line);background:#0c152a;border-radius:.4rem;padding:.1rem .35rem}
    .tab-active{background:#0f172a;border-color:#2a375c}
    .hr{height:1px;background:var(--line)}
    .tooltip{position:relative}
    .tooltip:hover::after{
      content: attr(data-tip);
      position:absolute;left:0;top:100%;transform:translateY(.4rem);
      background:#0d1428;border:1px solid var(--line);color:var(--ink);
      white-space:pre-wrap;font-size:.75rem;padding:.35rem .5rem;border-radius:.5rem;min-width:12rem;z-index:30
    }
    .badge{background:#0a1022;border:1px solid #1b284d;padding:.25rem .55rem;border-radius:.5rem;font-size:.75rem}
    .title{letter-spacing:.2px}
    .link{color:#93c5fd}
    .ok{color:var(--ok)} .warn{color:var(--warn)} .err{color:var(--err)}
    .shadow-card{box-shadow: 0 10px 30px rgba(0,0,0,.35);}
    .card{background:var(--card)}
    .grid-2{display:grid;grid-template-columns:1fr;gap:1rem}
    .grid-3{display:grid;grid-template-columns:1fr;gap:1rem}
    @media(min-width:1024px){ .grid-2{grid-template-columns:2fr 1.1fr} .grid-3{grid-template-columns:repeat(3,1fr)} }
    .logline{font-size:.8rem;white-space:pre-wrap;border-bottom:1px dashed #122041;padding:.25rem .35rem}
    .pill{border:1px solid var(--line);background:#0d1426;border-radius:9999px;padding:.15rem .6rem}
  </style>
</head>
<body class="min-h-screen">

  
  <script>
    /* =========================
       CONFIG & STATE (improved)
       ========================= */

    // ABI loader (unchanged path per request)
    const ABI_URL = "../abi/CatalystNFTStakingUpgradeable.json";

    // You confirmed this proxy is correct — kept as default.
    const DEFAULT_CONTRACT = "0xF6f4B2eb6b9D4e87fA5D38DE9124Dd4C212a61FD";

    // Default read RPC (Core testnet)
    const DEFAULT_RPC = "https://rpc.test.btcs.network/";

    // Minimal ERC-721 helper ABI (used only for approvals/checks)
    const ERC721_ABI = [
      "function setApprovalForAll(address operator, bool approved)",
      "function isApprovedForAll(address owner, address operator) view returns (bool)",
      "function approve(address to, uint256 tokenId)",
      "function getApproved(uint256 tokenId) view returns (address)"
    ];

    // Internal state
    let READ_PROVIDER = null;
    let WALLET_PROVIDER = null;
    let SIGNER = null;
    let USER_ADDR = null;

    let ABI = null;
    let READ_CONTRACT = null;
    let WRITE_CONTRACT = null;
    let CONTRACT_ADDR = "";

    let refreshTimer = null;

    /* =========================
       DOM HELPERS & LOG
       ========================= */
    const $ = id => document.getElementById(id);
    function now(){ return new Date().toLocaleTimeString(); }
    function log(msg, cls=""){
      try {
        const wrap = $("log");
        const div = document.createElement("div");
        div.className = "logline " + (cls||"");
        div.textContent = `[${now()}] ${msg}`;
        wrap.prepend(div);
      } catch {}
      // also console
      if (cls === "err") console.error(msg); else console.debug(msg);
    }
    function setYear(){ try { $("year").textContent = new Date().getFullYear(); } catch {} }
    setYear();

    /* =========================
       MODAL (CONFIRMATIONS)
       ========================= */
    let modalResolver = null;
    function confirmModal({title, body, icon="⚠️", danger=false}){
      $("modalTitle").textContent = title;
      $("modalBody").textContent = body;
      $("modalIcon").textContent = icon;
      $("modalOk").className = danger ? "btn btn-danger" : "btn btn-primary";
      $("modal").classList.remove("hidden");
      return new Promise((resolve)=>{
        modalResolver = resolve;
      });
    }
    $("modalCancel")?.addEventListener("click", ()=>{ $("modal").classList.add("hidden"); modalResolver?.(false); });
    $("modalOk")?.addEventListener("click", ()=>{ $("modal").classList.add("hidden"); modalResolver?.(true); });

    /* =========================
       ABI / PROVIDERS (robust)
       ========================= */
    async function loadABI(){
      if (ABI) return ABI;
      try {
        const res = await fetch(ABI_URL, {cache:"no-store"});
        if (!res.ok) throw new Error(`ABI load failed: ${res.status} ${res.statusText}`);
        const json = await res.json();
        ABI = Array.isArray(json) ? json : (json.abi || json);
        if(!Array.isArray(ABI)) throw new Error("ABI array not found in JSON");
        log(`ABI loaded (${ABI.length} entries)`, "ok");
        return ABI;
      } catch (e) {
        log(`Failed to load ABI at ${ABI_URL}: ${e.message||e}`, "err");
        throw e;
      }
    }

    async function setupReadProvider(customRpc){
      try{
        // prefer explicit RPC if provided, otherwise default to a JSON-RPC provider
        const rpc = customRpc || localStorage.getItem("catalyst_rpc") || DEFAULT_RPC;
        READ_PROVIDER = new ethers.JsonRpcProvider(rpc);
        log(`Read provider set -> ${rpc}`, "ok");
        return READ_PROVIDER;
      }catch(e){
        log(`Read provider error: ${e.message||e}`, "err");
        READ_PROVIDER = null;
        throw e;
      }
    }

    async function connectWallet(){
      if(!window.ethereum) throw new Error("No injected wallet found (MetaMask / WalletConnect)");
      // BrowserProvider wraps window.ethereum for ethers v6
      WALLET_PROVIDER = new ethers.BrowserProvider(window.ethereum);
      // request access
      await WALLET_PROVIDER.send("eth_requestAccounts", []);
      SIGNER = await WALLET_PROVIDER.getSigner();
      USER_ADDR = await SIGNER.getAddress();
      $("acct").textContent = USER_ADDR;
      $("walletBtn").textContent = "Disconnect";
      log(`Wallet connected: ${USER_ADDR}`, "ok");

      // initialize write contract immediately so writes are ready
      try {
        await initWriteContract();
      } catch(e){
        log(`Init write contract failed: ${e.message||e}`, "err");
      }
    }

    function requireWallet(){
      if(!USER_ADDR || !SIGNER) throw new Error("Please connect wallet first");
    }

    function saveContractAddress(addr){
      localStorage.setItem("catalyst_contract", addr);
      CONTRACT_ADDR = addr;
      $("contractAddress").value = addr;
      $("contractAddress_m").value = addr;
      log(`Saved contract: ${addr}`, "ok");
    }
    function getSavedAddress(){
      return localStorage.getItem("catalyst_contract") || DEFAULT_CONTRACT;
    }

    async function initReadContract(){
      // ensure contract address is set
      if(!CONTRACT_ADDR) CONTRACT_ADDR = getSavedAddress();
      if(!CONTRACT_ADDR) throw new Error("Contract address empty");
      if(!READ_PROVIDER) await setupReadProvider();
      const abi = await loadABI();
      READ_CONTRACT = new ethers.Contract(CONTRACT_ADDR, abi, READ_PROVIDER);
      // quick sanity: check bytecode is present
      try {
        const code = await READ_PROVIDER.getCode(CONTRACT_ADDR);
        if (!code || code === "0x") log(`Warning: No bytecode at ${CONTRACT_ADDR}`, "warn");
      } catch (e) {
        log(`Could not fetch code at ${CONTRACT_ADDR}: ${e.message||e}`, "warn");
      }
      return READ_CONTRACT;
    }

    async function initWriteContract(){
      requireWallet();
      if(!CONTRACT_ADDR) CONTRACT_ADDR = getSavedAddress();
      if(!CONTRACT_ADDR) throw new Error("Contract address empty");
      const abi = await loadABI();
      WRITE_CONTRACT = new ethers.Contract(CONTRACT_ADDR, abi, SIGNER);
      return WRITE_CONTRACT;
    }

    /* =========================
       PARSERS
       ========================= */
    function parseAddress(v){
      const s = (v||"").trim();
      if(!ethers.isAddress(s)) throw new Error("Invalid address");
      return s;
    }
    function parseUint(v, fallback=0n){
      const s = (v??"").toString().trim();
      if(!s) return BigInt(fallback);
      return BigInt(s);
    }
    function parseIdsCSV(csv){
      return (csv||"").split(",").map(s=>s.trim()).filter(Boolean).map(s=>BigInt(s));
    }

    /* =========================
       NETWORK SAFETY CHECK
       ========================= */
    async function checkNetworkIsCoreTestnet(provider){
      // We can't rely on chainId being exact across forks; instead warn if network doesn't look like a Core RPC.
      try {
        if (!provider) return false;
        const net = await provider.getNetwork();
        const name = (net?.name||"").toLowerCase();
        // best-effort check: rpc.test.btcs.network is Core testnet; chain name may not be 'core'
        if (name.includes("core") || name.includes("btcs") || (provider.connection && provider.connection.url && provider.connection.url.includes("test.btcs"))) {
          return true;
        }
        // otherwise warn, but still allow actions if user insists
        log(`Connected to network: ${net?.chainId || net?.name}. Recommended: Core Testnet.`, "warn");
        return false;
      } catch(e){
        log(`Network check failed: ${e.message||e}`, "warn");
        return false;
      }
    }

    /* =========================
       STATS (READ)
       ========================= */
    async function refreshStats(){
      try{
        await initReadContract();
        await checkNetworkIsCoreTestnet(READ_PROVIDER);
        // using expected names; adjust if your ABI differs
        let s;
        try {
          s = await READ_CONTRACT.stakingStats();
        } catch(e) {
          // fallback: contract might expose separate getters - just show an error
          log(`stakingStats() read failed: ${shortErr(e)}`, "err");
          return;
        }
        $("st_totalAll").textContent = s.totalAll?.toString?.() || s[0]?.toString?.() || "—";
        $("st_totalTerm").textContent = s.totalTerm?.toString?.() || s[1]?.toString?.() || "—";
        $("st_totalPermanent").textContent = s.totalPermanent?.toString?.() || s[2]?.toString?.() || "—";
        $("st_remainingGlobal").textContent = s.remainingGlobal?.toString?.() || s[3]?.toString?.() || "—";
        $("st_remainingTerm").textContent = s.remainingTerm?.toString?.() || s[4]?.toString?.() || "—";
        $("st_remainingPermanent").textContent = s.remainingPermanent?.toString?.() || s[5]?.toString?.() || "—";

        try{
          const tb = await READ_CONTRACT.treasuryBalance();
          $("st_treasury").textContent = tb.toString();
        }catch{ $("st_treasury").textContent = "n/a"; }

        try{
          const dep = await READ_CONTRACT.deployerAddress();
          $("st_deployer").textContent = dep;
        }catch{ $("st_deployer").textContent = "n/a"; }

        try{
          const paused = await READ_CONTRACT.paused();
          $("st_paused").textContent = paused ? "true" : "false";
        }catch{ $("st_paused").textContent = "n/a"; }

        log("Stats refreshed", "ok");
      }catch(e){
        log(`Stats error: ${shortErr(e)}`, "err");
      }
    }
    function toggleAutoRefresh(on){
      if (refreshTimer){ clearInterval(refreshTimer); refreshTimer = null; }
      if (on){ refreshTimer = setInterval(refreshStats, 8000); }
    }

    /* =========================
       TABS wiring (unchanged behaviour)
       ========================= */
    function selectTab(key){
      document.querySelectorAll(".tabbtn").forEach(b=>b.classList.remove("tab-active"));
      document.querySelectorAll("[id^='tab-']").forEach(el=>el.classList.add("hidden"));
      document.querySelector(`[data-tab='${key}']`)?.classList.add("tab-active");
      document.getElementById(`tab-${key}`)?.classList.remove("hidden");
      if(key === "whitepaper"){ location.hash = "tab-whitepaper"; }
    }

    /* =========================
       UTIL: better error shortener (shows revert reason when possible)
       ========================= */
    function shortErr(e){
      try {
        if (!e) return String(e);
        // ethers v6 revert structure: e?.reason or e?.data?.message or e?.error?.message
        if (e?.reason) return e.reason;
        if (e?.data?.message) return e.data.message;
        if (e?.error?.message) return e.error.message;
        if (e?.message) return e.message;
        return JSON.stringify(e).slice(0,240);
      } catch(err){ return String(e); }
    }

    /* =========================
       DOCUMENT READY + Initialization
       ========================= */
    document.addEventListener("DOMContentLoaded", ()=>{
      document.querySelectorAll(".tabbtn").forEach(btn=>{
        btn.onclick = ()=> selectTab(btn.dataset.tab);
      });

      // Header actions
      $("saveRpc").onclick = async ()=>{
        const url = $("rpcUrl").value.trim();
        localStorage.setItem("catalyst_rpc", url);
        await setupReadProvider(url);
        if (CONTRACT_ADDR){
          try{ await initReadContract(); log("Read contract re-initialized", "ok"); }catch(e){ log(e.message||e,"err"); }
        }
      };
      $("saveRpc_m").onclick = async ()=>{
        const url = $("rpcUrl_m").value.trim();
        localStorage.setItem("catalyst_rpc", url);
        $("rpcUrl").value = url;
        await setupReadProvider(url);
        if (CONTRACT_ADDR){
          try{ await initReadContract(); log("Read contract re-initialized", "ok"); }catch(e){ log(e.message||e,"err"); }
        }
      };

      $("saveContractBtn").onclick = ()=>{ try{ saveContractAddress($("contractAddress").value.trim()); }catch(e){ log(e.message||e,"err"); } };
      $("saveContractBtn_m").onclick = ()=>{ try{ saveContractAddress($("contractAddress_m").value.trim()); }catch(e){ log(e.message||e,"err"); } };

      $("walletBtn").onclick = async ()=>{
        try{
          if(!USER_ADDR){
            await connectWallet();
            $("walletBtn").textContent = "Disconnect";
          }else{
            USER_ADDR = null; SIGNER = null; WRITE_CONTRACT = null; WALLET_PROVIDER = null;
            $("acct").textContent = "Not connected";
            $("walletBtn").textContent = "Connect";
            log("Wallet disconnected (local)", "warn");
          }
        }catch(e){ log(shortErr(e), "err"); }
      };

      $("btnRefresh").onclick = refreshStats;
      $("autoRefresh").onchange = (e)=> toggleAutoRefresh(e.target.checked);

      log("UI ready — background init starting…", "ok");
    });

    window.addEventListener("load", async ()=>{
      try{
        // load saved RPC and contract address
        const savedRpc = localStorage.getItem("catalyst_rpc") || DEFAULT_RPC;
        $("rpcUrl").value = savedRpc; $("rpcUrl_m").value = savedRpc;
        await setupReadProvider(savedRpc);

        const saved = getSavedAddress();
        if(saved){
          $("contractAddress").value = saved;
          $("contractAddress_m").value = saved;
          CONTRACT_ADDR = saved;
          try{ await initReadContract(); log("Read contract preloaded", "ok"); }catch(e){ log(shortErr(e),"err"); }
        } else {
          // populate UI with default proxy
          saveContractAddress(DEFAULT_CONTRACT);
          try{ await initReadContract(); log("Read contract preloaded (default)", "ok"); }catch(e){ log(shortErr(e),"err"); }
        }

        // if wallet already connected, restore signer
        if(window.ethereum){
          try{
            const accounts = await window.ethereum.request({ method:"eth_accounts" });
            if(accounts && accounts.length){
              WALLET_PROVIDER = new ethers.BrowserProvider(window.ethereum);
              SIGNER = await WALLET_PROVIDER.getSigner();
              USER_ADDR = accounts[0];
              $("acct").textContent = USER_ADDR;
              $("walletBtn").textContent = "Disconnect";
              try { await initWriteContract(); } catch(_){}
              log(`Wallet restored: ${USER_ADDR}`, "ok");
            }
          }catch(e){ /* ignore */ }
        }

        if(CONTRACT_ADDR) await refreshStats();
        log("Background init complete", "ok");
      }catch(e){
        log(`Init error: ${shortErr(e)}`, "err");
      }
    });

    /* =========================
       WRITE/READ ACTIONS (improved)
       ========================= */

    // Approve (setApprovalForAll)
    $("btnApprove721").onclick = async ()=>{
      try{
        requireWallet();
        await initWriteContract();
        const col = parseAddress($("colStake").value);
        const nft = new ethers.Contract(col, ERC721_ABI, SIGNER);

        // check current isApprovedForAll first
        try{
          const ok = await nft.isApprovedForAll(USER_ADDR, CONTRACT_ADDR);
          if(ok){
            log("Contract already set as operator for your NFTs", "ok");
            return;
          }
        }catch(e){ /* ignore if method not available */ }

        const tx = await nft.setApprovalForAll(CONTRACT_ADDR, true);
        log(`Approval sent: ${tx.hash}`);
        await tx.wait();
        log("Approval confirmed ✅", "ok");
      }catch(e){ log(shortErr(e), "err"); }
    };

    // Check approval for specific collection
    $("btnApprove721Check").onclick = async ()=>{
      try{
        await initReadContract();
        const col = parseAddress($("colStake").value);
        if(!USER_ADDR){ log("Connect wallet to check isApprovedForAll for your account", "warn"); return; }
        const nft = new ethers.Contract(col, ERC721_ABI, READ_PROVIDER);
        const ok = await nft.isApprovedForAll(USER_ADDR, CONTRACT_ADDR);
        log(`isApprovedForAll = ${ok}`, ok ? "ok" : "warn");
      }catch(e){ log(shortErr(e), "err"); }
    };

    // Single stake + optional auto-approval (auto-check)
    $("btnStake").onclick = async ()=>{
      try{
        requireWallet();
        const isPerm = $("permanent").value === "true";
        // confirm permanent if selected
        if(isPerm){
          const ok = await confirmModal({
            title: "Confirm Permanent Stake",
            body: "Permanent stake locks the NFT forever and cannot be unstaked. Proceed?",
            icon: "♾️",
            danger: true
          });
          if(!ok){ log("Permanent stake cancelled", "warn"); return; }
        }
        await initWriteContract();
        const col = parseAddress($("colStake").value);
        const id = parseUint($("tidStake").value);

        // auto-check approval: if not approved, offer to approve automatically
        const nft = new ethers.Contract(col, ERC721_ABI, SIGNER);
        let approved = false;
        try {
          approved = await nft.isApprovedForAll(USER_ADDR, CONTRACT_ADDR);
          if (!approved) {
            // try if token is individually approved to proxy
            try {
              const approvedAddr = await nft.getApproved(id);
              if (approvedAddr && approvedAddr.toLowerCase() === CONTRACT_ADDR.toLowerCase()) approved = true;
            } catch {}
          }
        } catch {}

        if (!approved) {
          const doAuto = confirm("This token/collection is not approved. Approve setApprovalForAll now? (OK=yes / Cancel=no)");
          if (doAuto) {
            const txA = await nft.setApprovalForAll(CONTRACT_ADDR, true);
            log(`Approval tx sent: ${txA.hash}`);
            await txA.wait();
            log("Approval confirmed ✅", "ok");
          } else {
            log("Stake aborted: approval required", "warn");
            return;
          }
        }

        const tx = await WRITE_CONTRACT.stake(col, id, isPerm);
        log(`Stake sent: ${tx.hash}`);
        await tx.wait();
        log("Stake confirmed ✅", "ok");
      }catch(e){ log(shortErr(e), "err"); }
    };

    // Harvest single token
    $("btnHarvestOne").onclick = async ()=>{
      try{
        requireWallet();
        await initWriteContract();
        const col = parseAddress($("colStake").value);
        const id = parseUint($("tidStake").value);
        const tx = await WRITE_CONTRACT.harvestOne(col, id);
        log(`Harvest sent: ${tx.hash}`);
        await tx.wait();
        log("Harvest confirmed ✅", "ok");
      }catch(e){ log(shortErr(e), "err"); }
    };

    // Unstake
    $("btnUnstake").onclick = async ()=>{
      try{
        requireWallet();
        await initWriteContract();
        const col = parseAddress($("colStake").value);
        const id = parseUint($("tidStake").value);
        const tx = await WRITE_CONTRACT.unstake(col, id);
        log(`Unstake sent: ${tx.hash}`);
        await tx.wait();
        log("Unstake confirmed ✅", "ok");
      }catch(e){ log(shortErr(e),"err"); }
    };

    // View pending (read-only; owner optional)
    $("btnViewPending").onclick = async ()=>{
      try{
        // prefer read contract so wallet not required
        await initReadContract();
        const col = parseAddress($("colStake").value);
        const id = parseUint($("tidStake").value);
        // prefer standard pendingRewardOf; some ABIs may differ
        try {
          const pending = await READ_CONTRACT.pendingRewardOf(col, id);
          $("pendingView").textContent = ethers.formatUnits(pending, 18) + " CATA";
        } catch (e) {
          log(`pendingRewardOf not available: ${shortErr(e)}`, "err");
        }
      }catch(e){ log(shortErr(e),"err"); }
    };

    /* ============================
     * BLUE-CHIP (NON-CUSTODIAL)
     * ============================ */
    $("btnEnrollBlue").onclick = async ()=>{
      try{
        requireWallet();
        await initWriteContract();
        const tx = await WRITE_CONTRACT.enrollBluechip();
        log(`Blue-chip enrollment sent: ${tx.hash}`);
        await tx.wait();
        log("Enrollment confirmed ✅","ok");
      }catch(e){ log(shortErr(e),"err"); }
    };

    $("btnHarvestBlue").onclick = async ()=>{
      try{
        requireWallet();
        await initWriteContract();
        const col = parseAddress($("colBlueHarvest").value);
        const tx = await WRITE_CONTRACT.harvestBluechip(col);
        log(`Blue-chip harvest sent: ${tx.hash}`);
        await tx.wait();
        log("Blue-chip harvest confirmed ✅","ok");
      }catch(e){ log(shortErr(e),"err"); }
    };

    $("btnSetBlue").onclick = async ()=>{
      try {
        requireWallet();
        await initWriteContract();
        const col = parseAddress($("colFlagBlue").value);
        const flag = $("isBlueFlag").value === "true";
        const tx = await WRITE_CONTRACT.setBlueChip(col, flag);
        log(`Set blue-chip sent: ${tx.hash}`);
        await tx.wait();
        log(`Blue-chip ${flag ? "flagged" : "cleared"} ✅`, "ok");
      } catch(e){ log(shortErr(e), "err"); }
    };

    /* ============================
     * GOVERNANCE / GUARDIANS / ADMIN (kept behavior; better error messages)
     * ============================ */

    $("btnPropose").onclick = async ()=>{
      try {
        requireWallet();
        await initWriteContract();
        const pType = parseUint($("pType").value);
        const paramTarget = parseUint($("paramTarget").value || 0n);
        const newValue = parseUint($("newValue").value);
        const ctxRaw = $("collCtx").value.trim();
        const ctx = ctxRaw && ethers.isAddress(ctxRaw) ? ctxRaw : ethers.ZeroAddress;
        const tx = await WRITE_CONTRACT.propose(pType, paramTarget, newValue, ctx);
        log(`Propose sent: ${tx.hash}`);
        const rc = await tx.wait();
        log("Proposal created ✅ (check logs for ID)", "ok");
      } catch(e){ log(shortErr(e), "err"); }
    };

    $("btnVote").onclick = async ()=>{
      try {
        requireWallet();
        await initWriteContract();
        const id = $("propId").value.trim();
        if (!id) throw new Error("Proposal ID required");
        const tx = await WRITE_CONTRACT.vote(id);
        log(`Vote sent: ${tx.hash}`);
        await tx.wait();
        log("Vote confirmed ✅", "ok");
      } catch(e){ log(shortErr(e), "err"); }
    };

    $("btnExecute").onclick = async ()=>{
      try {
        requireWallet();
        await initWriteContract();
        const id = $("propId").value.trim();
        if (!id) throw new Error("Proposal ID required");
        const tx = await WRITE_CONTRACT.execute(id);
        log(`Execute sent: ${tx.hash}`);
        await tx.wait();
        log("Proposal executed ✅", "ok");
      } catch(e){ log(shortErr(e), "err"); }
    };

    // Guardians / Admin flows (kept behavior; sanitized inputs)
    $("btnPropDep").onclick = async ()=>{
      try{
        requireWallet();
        await initWriteContract();
        const addr = parseAddress($("newDeployer").value);
        const tx = await WRITE_CONTRACT.proposeDeployer(addr);
        log(`Propose new deployer sent: ${tx.hash}`);
        await tx.wait();
        log("New deployer proposed ✅", "ok");
      }catch(e){ log(shortErr(e),"err"); }
    };

    $("btnApproveDep").onclick = async ()=>{
      try{
        requireWallet();
        await initWriteContract();
        const addr = parseAddress($("newDeployer").value);
        const tx = await WRITE_CONTRACT.approveDeployer(addr);
        log(`Approve new deployer sent: ${tx.hash}`);
        await tx.wait();
        log("Approval recorded ✅", "ok");
      }catch(e){ log(shortErr(e),"err"); }
    };

    $("btnExecDep").onclick = async ()=>{
      try{
        requireWallet();
        const addr = parseAddress($("newDeployer").value);
        const ok = await confirmModal({ title:"⚠️ Execute Deployer Recovery", body:`New Deployer: ${addr}\nProceed?`, danger:true });
        if (!ok) return;
        await initWriteContract();
        const tx = await WRITE_CONTRACT.executeDeployer(addr);
        log(`Execute deployer recovery sent: ${tx.hash}`);
        await tx.wait();
        log("Deployer recovery executed ✅", "ok");
      }catch(e){ log(shortErr(e),"err"); }
    };

    $("btnPropAdm").onclick = async ()=>{
      try{
        requireWallet();
        await initWriteContract();
        const addr = parseAddress($("newAdmin").value);
        const tx = await WRITE_CONTRACT.proposeAdmin(addr);
        log(`Propose new admin sent: ${tx.hash}`);
        await tx.wait();
        log("New admin proposed ✅", "ok");
      }catch(e){ log(shortErr(e),"err"); }
    };

    $("btnApproveAdm").onclick = async ()=>{
      try{
        requireWallet();
        await initWriteContract();
        const addr = parseAddress($("newAdmin").value);
        const tx = await WRITE_CONTRACT.approveAdmin(addr);
        log(`Approve new admin sent: ${tx.hash}`);
        await tx.wait();
        log("Approval recorded ✅", "ok");
      }catch(e){ log(shortErr(e),"err"); }
    };

    $("btnExecAdm").onclick = async ()=>{
      try{
        requireWallet();
        const addr = parseAddress($("newAdmin").value);
        const ok = await confirmModal({ title:"⚠️ Execute Admin Recovery", body:`New Admin: ${addr}\nProceed?`, danger:true });
        if (!ok) return;
        await initWriteContract();
        const tx = await WRITE_CONTRACT.executeAdmin(addr);
        log(`Execute admin recovery sent: ${tx.hash}`);
        await tx.wait();
        log("Admin recovery executed ✅", "ok");
      }catch(e){ log(shortErr(e),"err"); }
    };

    /* ============================
       ADMIN: PAUSE / UNPAUSE / WITHDRAW
       ============================ */
    $("btnPause").onclick = async ()=>{
      try{
        requireWallet();
        await initWriteContract();
        const tx = await WRITE_CONTRACT.pause();
        log(`Pause sent: ${tx.hash}`);
        await tx.wait();
        log("Contract paused ✅", "ok");
        try { $("st_paused").textContent = "true"; } catch(_){}
      }catch(e){ log(shortErr(e),"err"); }
    };

    $("btnUnpause").onclick = async ()=>{
      try{
        requireWallet();
        await initWriteContract();
        const tx = await WRITE_CONTRACT.unpause();
        log(`Unpause sent: ${tx.hash}`);
        await tx.wait();
        log("Contract unpaused ✅", "ok");
        try { $("st_paused").textContent = "false"; } catch(_){}
      }catch(e){ log(shortErr(e),"err"); }
    };

    $("btnWithdraw").onclick = async ()=>{
      try{
        requireWallet();
        const to = parseAddress($("toTreasury").value);
        const amt = parseUint($("amtTreasury").value);
        const ok = await confirmModal({ title:"⚠️ Treasury Withdraw", body:`Recipient: ${to}\nAmount (wei): ${amt}\nProceed?`, danger:true });
        if (!ok) return;
        await initWriteContract();
        const tx = await WRITE_CONTRACT.withdrawTreasury(to, amt);
        log(`Withdraw sent: ${tx.hash}`);
        await tx.wait();
        log("Treasury withdrawn ✅", "ok");
        try { await refreshStats(); } catch(_){}
      }catch(e){ log(shortErr(e),"err"); }
    };

    /* ============================
     * READ HELPERS (lists & info) - kept, minor resilience improvements
     * ============================ */

    $("btnViewPending2").onclick = async ()=>{
      try{
        await initReadContract();
        const col = parseAddress($("vCol").value);
        const ownerRaw = ($("vOwner").value||"").trim();
        const idStr = ($("vTokenId").value||"").trim();

        let out = "";
        if (idStr) {
          const id = parseUint(idStr);
          try{
            const v = await READ_CONTRACT.pendingRewardOf(col, id);
            out += `pendingRewardOf(${col}, #${id}) = ${ethers.formatUnits(v,18)} CATA\n`;
          }catch(e){
            out += `pendingRewardOf not available (${shortErr(e)})\n`;
          }
        }

        if (ownerRaw) {
          const owner = parseAddress(ownerRaw);
          try{
            const v2 = await READ_CONTRACT.pendingRewardOfOwner(col, owner);
            out += `pendingRewardOfOwner(${col}, ${owner}) = ${ethers.formatUnits(v2,18)} CATA\n`;
          }catch(e){
            out += `pendingRewardOfOwner not available (${shortErr(e)})\n`;
          }
        }

        if (!out) out = "Provide a token ID and/or Owner address.";
        $("pendingOut").textContent = out.trim();
      }catch(e){ log(shortErr(e), "err"); }
    };

    $("btnListCollections").onclick = async ()=>{
      try{
        await initReadContract();
        let lines = [];
        let listed = false;

        try{
          const arr = await READ_CONTRACT.getRegisteredCollections();
          arr.forEach((a,i)=>lines.push(`${i}. ${a}`));
          listed = true;
        }catch{}

        if (!listed){
          try{
            const n = await READ_CONTRACT.collectionCount();
            lines.push(`count = ${n}`);
            for (let i=0n; i<n && i<200n; i++){
              try{
                const a = await READ_CONTRACT.collectionAt(i);
                lines.push(`${i}. ${a}`);
              }catch{ break; }
            }
            listed = true;
          }catch{}
        }

        $("collectionsOut").textContent = listed ? lines.join("\n") : "No listing method available on this ABI.";
      }catch(e){ log(shortErr(e), "err"); }
    };

    $("btnListBlue").onclick = async ()=>{
      try{
        await initReadContract();
        let lines = [];
        let listed = false;

        try{
          const arr = await READ_CONTRACT.getBlueChips();
          arr.forEach((a,i)=>lines.push(`${i}. ${a}`));
          listed = true;
        }catch{}

        if (!listed){
          try{
            const n = await READ_CONTRACT.collectionCount();
            for (let i=0n; i<n && i<200n; i++){
              try{
                const a = await READ_CONTRACT.collectionAt(i);
                const flag = await READ_CONTRACT.isBlueChip(a);
                if (flag) lines.push(`${i}. ${a}`);
              }catch{}
            }
            listed = true;
          }catch{}
        }

        $("collectionsOut").textContent = listed ? (lines.length?lines.join("\n"):"(none flagged)") : "No blue-chip listing method available.";
      }catch(e){ log(shortErr(e), "err"); }
    };

    $("btnUserInfo").onclick = async ()=>{
      try{
        await initReadContract();
        const who = ($("infoUser").value||"").trim() || USER_ADDR;
        if (!who) throw new Error("Provide user or connect wallet");
        const addr = parseAddress(who);

        let out = [`User: ${addr}`];

        try{
          const bal = await READ_CONTRACT.balanceOf(addr);
          out.push(`CATA balanceOf = ${ethers.formatUnits(bal,18)}`);
        }catch{}
        try{
          const st = await READ_CONTRACT.userStakeCount(addr);
          out.push(`userStakeCount = ${st}`);
        }catch{}
        try{
          const en = await READ_CONTRACT.isBluechipEnrolled(addr);
          out.push(`bluechip enrolled = ${en}`);
        }catch{}

        $("infoOut").textContent = out.join("\n");
      }catch(e){ log(shortErr(e), "err"); }
    };

    $("btnColInfo").onclick = async ()=>{
      try{
        await initReadContract();
        const col = parseAddress($("infoCol").value);
        let out = [`Collection: ${col}`];

        try{
          const info = await READ_CONTRACT.collectionInfo(col);
          if (info.maxSupply) out.push(`maxSupply = ${info.maxSupply}`);
          if (info.verified!==undefined) out.push(`verified = ${info.verified}`);
          if (info.isBlue!==undefined) out.push(`bluechip = ${info.isBlue}`);
        }catch(e){ out.push(`collectionInfo not available (${shortErr(e)})`); }

        $("infoOut").textContent = out.join("\n");
      }catch(e){ log(shortErr(e), "err"); }
    };

    /* ============================
       Wallet event handlers (accounts/chain)
       ============================ */
    if (window.ethereum) {
      window.ethereum.on?.("accountsChanged", (accs)=>{
        if (!accs || accs.length === 0) {
          USER_ADDR = null; SIGNER = null; WRITE_CONTRACT = null;
          $("acct").textContent = "Not connected";
          $("walletBtn").textContent = "Connect";
          log("Wallet disconnected (accountsChanged)", "warn");
        } else {
          USER_ADDR = accs[0];
          $("acct").textContent = USER_ADDR;
          $("walletBtn").textContent = "Disconnect";
          log(`Account switched → ${USER_ADDR}`, "ok");
          // refresh signer lazy on next write
          WRITE_CONTRACT = null;
        }
      });

      window.ethereum.on?.("chainChanged", async ()=>{
        WRITE_CONTRACT = null; SIGNER = null;
        // When chain changes, force re-init of read provider and contract
        try{ await setupReadProvider(localStorage.getItem("catalyst_rpc") || DEFAULT_RPC); await initReadContract(); log("Chain changed — refreshed read contract", "warn"); } catch(e){ log(shortErr(e),"warn"); }
      });
    }

    /* ============================
       Final ready message
       ============================ */
    log("Action wiring complete — DApp ready ✅", "ok");
  </script>
</body>
</html>
