// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/* ========= Local Libraries ========= */
import "./StakingLib.sol";
import "./GovernanceLib.sol";
import "./BluechipLib.sol";
import "./GuardianLib.sol";

/* ========= OpenZeppelin (Upgradeable) ========= */
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

/**
 * @title CatalystNFTStakingUpgradeable v2 (guardian-extracted)
 * @notice Upgradeable ERC20 (CATA) + custodial staking + blue-chip non-custodial + governance.
 *         Guardian council + recovery are implemented in GuardianLib to reduce bytecode size.
 */
contract CatalystNFTStakingUpgradeable is
    Initializable,
    UUPSUpgradeable,
    ERC20Upgradeable,
    AccessControlUpgradeable,
    ReentrancyGuardUpgradeable,
    PausableUpgradeable,
    IERC721Receiver
{
    using StakingLib for StakingLib.Storage;
    using GuardianLib for GuardianLib.Storage;

    /* ========= Custom Errors ========= */
    error ZeroAddress();
    error BadParam();
    error NotRegistered();
    error AlreadyExists();
    error NotStaked();
    error TermNotExpired();
    error Cooldown();
    error BatchTooLarge();
    error Ineligible();
    error Unauthorized();
    error NoRequest();
    error Expired();
    error AlreadyApproved();
    error Threshold();
    error Insufficient();
    error NotERC721Sender();
    error Throttled();

    /* ========= Roles ========= */
    bytes32 public constant CONTRACT_ADMIN_ROLE = keccak256("CONTRACT_ADMIN_ROLE");

    /* ========= Economic Constants ========= */
    uint256 public constant BURN_BP     = 9000;  // 90%
    uint256 public constant TREASURY_BP = 900;   // 9%
    uint256 public constant DEPLOYER_BP = 100;   // 1%
    uint256 public constant BP_DENOM    = 10000;

    // staking caps (mirror StakingLib)
    uint256 public constant GLOBAL_CAP = 1_000_000_000;
    uint256 public constant TERM_CAP   =   750_000_000;
    uint256 public constant PERM_CAP   =   250_000_000;

    uint256 public constant MAX_HARVEST_BATCH        = 50;
    uint256 public constant MAX_STAKE_PER_COLLECTION = 20_000;
    uint256 public constant WEIGHT_SCALE             = 1e18;

    /* ========= Library Storage ========= */
    StakingLib.Storage    internal s;   // custodial staking
    GovernanceLib.Storage internal g;   // governance
    BluechipLib.Storage   internal b;   // blue-chip non-custodial
    GuardianLib.Storage   internal gu;  // guardians + recovery (extracted)

    /* ========= Protocol Params ========= */
    uint256 public numberOfBlocksPerRewardUnit;
    uint256 public termDurationBlocks;
    uint256 public stakingCooldownBlocks;
    uint256 public rewardRateIncrementPerNFT;
    uint256 public initialHarvestBurnFeeRate; // 0..100 (% burned from reward at harvest)
    uint256 public unstakeBurnFee;            // flat CATA fee on unstake

    // collection registration fee (fallback/min)
    uint256 public collectionRegistrationFee;

    // treasury + deployer
    address public treasuryAddress; // contract holds treasury CATA (address(this))
    address public deployerAddress; // 1% fee receiver
    uint256 public treasuryBalance;

    // governance helpers
    uint256 public minStakeAgeForVoting;
    uint256 public maxBaseRewardRate;

    // registered collections
    address[] public registeredCollections;
    mapping(address => uint256) public registeredIndex; // index+1 (0 == not registered)

    // bookkeeping (optional)
    mapping(address => uint256) public burnedCatalystByAddress;

    // anti-spam per wallet
    mapping(address => uint256) public lastStakingBlock;

    // light governance spam throttling
    mapping(address => uint256) public lastProposalBlock;

    /* ========= Events (non-guardian) ========= */
    event CollectionAdded(address indexed collection, uint256 declaredSupply, uint256 paid);
    event NFTStaked(address indexed owner, address indexed collection, uint256 indexed tokenId, bool permanent);
    event NFTUnstaked(address indexed owner, address indexed collection, uint256 indexed tokenId);
    event RewardsHarvested(address indexed owner, address indexed collection, uint256 gross, uint256 burned);
    event TreasuryDeposit(address indexed from, uint256 amount);
    event TreasuryWithdrawal(address indexed to, uint256 amount);

    event BaseRewardRateUpdated(uint256 oldValue, uint256 newValue);
    event HarvestFeeUpdated(uint256 oldValue, uint256 newValue);
    event UnstakeFeeUpdated(uint256 oldValue, uint256 newValue);
    event RegistrationFeeUpdated(uint256 oldValue, uint256 newValue);
    event VotingParamUpdated(uint8 target, uint256 oldValue, uint256 newValue);
    event ProposalExecuted(bytes32 indexed id, uint256 appliedValue);

    event BluechipCollectionSet(address indexed collection, bool isBluechip);

    /* ========= Modifiers ========= */

    modifier onlyRegistered(address collection) {
        if (registeredIndex[collection] == 0) revert NotRegistered();
        _;
    }

    modifier notInCooldown() {
        if (stakingCooldownBlocks > 0 && block.number < lastStakingBlock[_msgSender()] + stakingCooldownBlocks) {
            revert Cooldown();
        }
        _;
    }

    /* ========= Initializer ========= */

    struct InitConfig {
        address owner;

        // fees & rewards
        uint256 rewardRateIncrementPerNFT;
        uint256 initialHarvestBurnFeeRate;   // 0..100
        uint256 unstakeBurnFee;              // flat CATA
        uint256 termDurationBlocks;
        uint256 numberOfBlocksPerRewardUnit;
        uint256 collectionRegistrationFee;
        uint256 stakingCooldownBlocks;

        // governance
        uint256 votingDurationBlocks;
        uint256 minVotesRequiredScaled;
        uint256 collectionVoteCapPercent;    // 0..100
        uint256 minStakeAgeForVoting;
        uint256 maxBaseRewardRate;           // clamp upper bound (0 to disable)

        // guardians (see GuardianLib for sizes / thresholds)
        address[] deployerGuardians;         // exactly GuardianLib.DEPLOYER_GCOUNT
        address[] adminGuardians;            // exactly GuardianLib.ADMIN_GCOUNT

        // blue-chip
        uint256 bluechipWalletFee;           // per-wallet enrollment fee (Option A)
    }

    function initialize(InitConfig calldata cfg) external initializer {
        if (cfg.owner == address(0)) revert ZeroAddress();

        __ERC20_init("Catalyst", "CATA");
        __AccessControl_init();
        __UUPSUpgradeable_init();
        __ReentrancyGuard_init();
        __Pausable_init();

        _grantRole(DEFAULT_ADMIN_ROLE, cfg.owner);
        _grantRole(CONTRACT_ADMIN_ROLE, cfg.owner);

        deployerAddress  = cfg.owner;
        treasuryAddress  = address(this);

        rewardRateIncrementPerNFT   = cfg.rewardRateIncrementPerNFT;
        initialHarvestBurnFeeRate   = cfg.initialHarvestBurnFeeRate;
        unstakeBurnFee              = cfg.unstakeBurnFee;
        termDurationBlocks          = cfg.termDurationBlocks;
        numberOfBlocksPerRewardUnit = cfg.numberOfBlocksPerRewardUnit;
        collectionRegistrationFee   = cfg.collectionRegistrationFee;
        stakingCooldownBlocks       = cfg.stakingCooldownBlocks;

        minStakeAgeForVoting = cfg.minStakeAgeForVoting;
        maxBaseRewardRate    = cfg.maxBaseRewardRate == 0 ? type(uint256).max : cfg.maxBaseRewardRate;

        // Governance init
        GovernanceLib.initGov(
            g,
            cfg.votingDurationBlocks,
            cfg.minVotesRequiredScaled,
            cfg.collectionVoteCapPercent
        );

        // Guardians init (extracted into lib; enforces sizes, non-zero, uniqueness, etc.)
        gu.initGuardians(cfg.deployerGuardians, cfg.adminGuardians);

        // Blue-chip config (Option A: per-wallet fee)
        b.bluechipWalletFee = cfg.bluechipWalletFee;

        // One-time genesis mint to deployer/owner
        _mint(cfg.owner, 100_000_000 * 1e18);
    }

    /* ========= Guardian Council & Recovery (wrapped to GuardianLib) ========= */

    // Admin can rotate a deployer guardian (strictly non-zero, no duplicates) — checks inside lib.
    function setDeployerGuardian(uint8 idx, address guardian)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
        whenNotPaused
    {
        gu.setDeployerGuardian(idx, guardian);
    }

    // Admin can rotate an admin guardian.
    function setAdminGuardian(uint8 idx, address guardian)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
        whenNotPaused
    {
        gu.setAdminGuardian(idx, guardian);
    }

    // Deployer recovery (7:5) — propose, approve, execute
    function proposeDeployerRecovery(address newDeployer) external whenNotPaused {
        gu.guardianOnlyDeployer(_msgSender());       // reverts if not a deployer guardian
        gu.proposeDeployerRecovery(newDeployer);
    }

    function approveDeployerRecovery() external whenNotPaused {
        gu.guardianOnlyDeployer(_msgSender());
        gu.approveDeployerRecovery(_msgSender());
    }

    function executeDeployerRecovery() external whenNotPaused {
        address newDeployer = gu.executeDeployerRecovery();
        // apply in protocol (reflect new deployer fee receiver)
        deployerAddress = newDeployer;
    }

    // Admin recovery (7:5) — propose, approve, execute
    function proposeAdminRecovery(address newAdmin) external whenNotPaused {
        gu.guardianOnlyAdmin(_msgSender());
        gu.proposeAdminRecovery(newAdmin);
    }

    function approveAdminRecovery() external whenNotPaused {
        gu.guardianOnlyAdmin(_msgSender());
        gu.approveAdminRecovery(_msgSender());
    }

    function executeAdminRecovery() external whenNotPaused {
        address newAdmin = gu.executeAdminRecovery();
        _grantRole(DEFAULT_ADMIN_ROLE, newAdmin);
    }

    /* ========= Registration ========= */

    function registerCollection(address collection, uint256 declaredMaxSupply)
        external
        whenNotPaused
        nonReentrant
    {
        if (collection == address(0)) revert ZeroAddress();
        if (registeredIndex[collection] != 0) revert AlreadyExists();
        if (declaredMaxSupply == 0 || declaredMaxSupply > MAX_STAKE_PER_COLLECTION) revert BadParam();

        // pay fallback min fee (uniform; governance can adjust)
        if (collectionRegistrationFee > 0) {
            _splitFeeFromSender(_msgSender(), collectionRegistrationFee);
        }

        s.initCollection(collection, declaredMaxSupply);

        registeredCollections.push(collection);
        registeredIndex[collection] = registeredCollections.length;

        emit CollectionAdded(collection, declaredMaxSupply, collectionRegistrationFee);
    }

    /* ========= Custodial Staking ========= */

    function stake(address collection, uint256 tokenId, bool permanent)
        public
        whenNotPaused
        nonReentrant
        notInCooldown
        onlyRegistered(collection)
    {
        IERC721(collection).safeTransferFrom(_msgSender(), address(this), tokenId);

        if (permanent) {
            s.recordPermanentStake(
                collection,
                _msgSender(),
                tokenId,
                block.number,
                rewardRateIncrementPerNFT
            );
        } else {
            s.recordTermStake(
                collection,
                _msgSender(),
                tokenId,
                block.number,
                termDurationBlocks,
                rewardRateIncrementPerNFT
            );
        }

        lastStakingBlock[_msgSender()] = block.number;
        emit NFTStaked(_msgSender(), collection, tokenId, permanent);
    }

    function batchStake(address collection, uint256[] calldata tokenIds, bool permanent)
        external
        whenNotPaused
        nonReentrant
        notInCooldown
        onlyRegistered(collection)
    {
        uint256 n = tokenIds.length;
        if (n == 0 || n > MAX_HARVEST_BATCH) revert BatchTooLarge();

        for (uint256 i = 0; i < n; ++i) {
            stake(collection, tokenIds[i], permanent);
        }
    }

    function harvest(address collection, uint256 tokenId)
        external
        whenNotPaused
        nonReentrant
        onlyRegistered(collection)
    {
        uint256 reward = s.pendingRewards(collection, _msgSender(), tokenId, numberOfBlocksPerRewardUnit);
        if (reward == 0) return;

        uint256 burnAmt = (reward * initialHarvestBurnFeeRate) / 100;
        _mint(_msgSender(), reward);
        if (burnAmt > 0) {
            _burn(_msgSender(), burnAmt);
            burnedCatalystByAddress[_msgSender()] += burnAmt;
        }
        s.updateLastHarvest(collection, _msgSender(), tokenId);

        emit RewardsHarvested(_msgSender(), collection, reward, burnAmt);
    }

    function unstake(address collection, uint256 tokenId)
        external
        whenNotPaused
        nonReentrant
        onlyRegistered(collection)
    {
        StakingLib.StakeInfo memory info = s.stakeLog[collection][_msgSender()][tokenId];
        if (!info.currentlyStaked) revert NotStaked();
        if (!info.isPermanent && block.number < info.unstakeDeadlineBlock) revert TermNotExpired();

        // harvest pending first
        uint256 reward = s.pendingRewards(collection, _msgSender(), tokenId, numberOfBlocksPerRewardUnit);
        if (reward > 0) {
            uint256 burnAmt = (reward * initialHarvestBurnFeeRate) / 100;
            _mint(_msgSender(), reward);
            if (burnAmt > 0) {
                _burn(_msgSender(), burnAmt);
                burnedCatalystByAddress[_msgSender()] += burnAmt;
            }
            s.updateLastHarvest(collection, _msgSender(), tokenId);
            emit RewardsHarvested(_msgSender(), collection, reward, burnAmt);
        }

        // flat unstake fee (charged in CATA; splits into burn/treasury/deployer)
        if (unstakeBurnFee > 0) {
            _splitFeeFromSender(_msgSender(), unstakeBurnFee);
        }

        s.recordUnstake(collection, _msgSender(), tokenId, rewardRateIncrementPerNFT);

        IERC721(collection).safeTransferFrom(address(this), _msgSender(), tokenId);
        emit NFTUnstaked(_msgSender(), collection, tokenId);
    }

    /* ========= Blue-chip (Non-Custodial) ========= */

    function setBluechipCollection(address collection, bool isBluechip)
        external
        onlyRole(CONTRACT_ADMIN_ROLE)
        whenNotPaused
        onlyRegistered(collection)
    {
        b.isBluechipCollection[collection] = isBluechip;
        emit BluechipCollectionSet(collection, isBluechip);
    }

    /// @notice One-time per-wallet enrollment to earn on ANY blue-chip collection they own.
    /// Uses fee == `collectionRegistrationFee` for uniform UX.
    function enrollBluechip() external whenNotPaused nonReentrant {
        uint256 fee = collectionRegistrationFee;
        BluechipLib.enroll(
            b,
            address(0),                 // global enrollment (see lib)
            _msgSender(),
            block.number,
            fee,
            _splitFeeFromSender         // fee splitter (payer, amount)
        );
    }

    /// @notice Harvest blue-chip rewards for a specific collection (non-custodial).
    /// Requires: flagged blue-chip, wallet enrolled, wallet owns >=1 token.
    function harvestBluechip(address collection)
        external
        whenNotPaused
        nonReentrant
        onlyRegistered(collection)
    {
        if (!b.isBluechipCollection[collection]) revert Ineligible();
        if (IERC721(collection).balanceOf(_msgSender()) == 0) revert Ineligible();

        BluechipLib.harvest(
            b,
            collection,
            _msgSender(),
            block.number,
            s.baseRewardRate,
            numberOfBlocksPerRewardUnit,
            _mintReward
        );
    }

    /* ========= Governance ========= */

    function propose(
        GovernanceLib.ProposalType pType,
        uint8 paramTarget,
        uint256 newValue,
        address collectionContext
    ) external whenNotPaused returns (bytes32) {
        (uint256 weight,) = _votingWeight(_msgSender());
        if (weight == 0) revert Ineligible();

        if (lastProposalBlock[_msgSender()] == block.number) revert Throttled();
        lastProposalBlock[_msgSender()] = block.number;

        return GovernanceLib.createProposal(
            g,
            pType,
            paramTarget,
            newValue,
            collectionContext,
            _msgSender(),
            block.number
        );
    }

    function vote(bytes32 id) external whenNotPaused {
        (uint256 weight, address attributedCollection) = _votingWeight(_msgSender());
        if (weight == 0) revert Ineligible();
        GovernanceLib.castVote(g, id, _msgSender(), weight, attributedCollection);
    }

    function executeProposal(bytes32 id) external whenNotPaused nonReentrant {
        GovernanceLib.Proposal memory p = GovernanceLib.validateForExecution(g, id);
        GovernanceLib.markExecuted(g, id);

        if (p.pType == GovernanceLib.ProposalType.BASE_REWARD) {
            uint256 old = s.baseRewardRate;
            uint256 nv  = p.newValue > maxBaseRewardRate ? maxBaseRewardRate : p.newValue;
            s.baseRewardRate = nv;
            emit BaseRewardRateUpdated(old, nv);
        } else if (p.pType == GovernanceLib.ProposalType.HARVEST_FEE) {
            uint256 old = initialHarvestBurnFeeRate;
            initialHarvestBurnFeeRate = p.newValue; // expect 0..100
            emit HarvestFeeUpdated(old, p.newValue);
        } else if (p.pType == GovernanceLib.ProposalType.UNSTAKE_FEE) {
            uint256 old = unstakeBurnFee;
            unstakeBurnFee = p.newValue;
            emit UnstakeFeeUpdated(old, p.newValue);
        } else if (p.pType == GovernanceLib.ProposalType.REGISTRATION_FEE_FALLBACK) {
            uint256 old = collectionRegistrationFee;
            collectionRegistrationFee = p.newValue;
            emit RegistrationFeeUpdated(old, p.newValue);
        } else if (p.pType == GovernanceLib.ProposalType.VOTING_PARAM) {
            uint8 t = p.paramTarget;
            if (t == 0) { uint256 old = g.minVotesRequiredScaled; g.minVotesRequiredScaled = p.newValue; emit VotingParamUpdated(t, old, p.newValue); }
            else if (t == 1) { uint256 old = g.votingDurationBlocks;    g.votingDurationBlocks    = p.newValue; emit VotingParamUpdated(t, old, p.newValue); }
            else if (t == 2) { uint256 old = g.collectionVoteCapPercent;g.collectionVoteCapPercent= p.newValue; emit VotingParamUpdated(t, old, p.newValue); }
            else revert BadParam();
        } else if (p.pType == GovernanceLib.ProposalType.TIER_UPGRADE) {
            // reserved for future expansion (kept lean)
        } else {
            revert BadParam();
        }

        emit ProposalExecuted(id, p.newValue);
    }

    /// @dev simple voting weight:
    ///  - any active custodial stake older than minStakeAge grants weight; or
    ///  - enrolled blue-chip + currently owns >=1 token in a flagged collection.
    function _votingWeight(address voter) internal view returns (uint256 weight, address attributedCollection) {
        // Check custodial stakes
        for (uint256 i = 0; i < registeredCollections.length; ++i) {
            address coll = registeredCollections[i];
            uint256[] storage port = s.stakePortfolioByUser[coll][voter];
            if (port.length == 0) continue;
            for (uint256 j = 0; j < port.length; ++j) {
                StakingLib.StakeInfo storage si = s.stakeLog[coll][voter][port[j]];
                if (si.currentlyStaked && block.number >= si.stakeBlock + minStakeAgeForVoting) {
                    return (WEIGHT_SCALE, coll);
                }
            }
        }
        // Blue-chip path
        for (uint256 i = 0; i < registeredCollections.length; ++i) {
            address coll = registeredCollections[i];
            if (b.isBluechipCollection[coll] && b.bluechipWallets[coll][voter].enrolled) {
                if (IERC721(coll).balanceOf(voter) > 0) {
                    return (WEIGHT_SCALE, coll);
                }
            }
        }
        return (0, address(0));
    }

    /* ========= Treasury / Fees ========= */

    function _splitFeeFromSender(address payer, uint256 amount) internal {
        if (amount == 0) return;
        if (balanceOf(payer) < amount) revert Insufficient();

        uint256 burnAmt     = (amount * BURN_BP)     / BP_DENOM;
        uint256 treasuryAmt = (amount * TREASURY_BP) / BP_DENOM;
        uint256 deployerAmt = amount - burnAmt - treasuryAmt;

        if (burnAmt > 0) _burn(payer, burnAmt);

        if (treasuryAmt > 0) {
            _transfer(payer, address(this), treasuryAmt);
            treasuryBalance += treasuryAmt;
            emit TreasuryDeposit(payer, treasuryAmt);
        }

        if (deployerAmt > 0) {
            _transfer(payer, deployerAddress, deployerAmt);
        }
    }

    function withdrawTreasury(address to, uint256 amount)
        external
        onlyRole(CONTRACT_ADMIN_ROLE)
        whenNotPaused
        nonReentrant
    {
        if (to == address(0)) revert ZeroAddress();
        if (amount > treasuryBalance) revert Insufficient();
        treasuryBalance -= amount;
        _transfer(address(this), to, amount);
        emit TreasuryWithdrawal(to, amount);
    }

    function _mintReward(address to, uint256 amount) internal {
        if (amount == 0) return;
        _mint(to, amount);
    }

    /* ========= Views ========= */

    function stakingStats() external view returns (
        uint256 totalAll,
        uint256 totalTerm,
        uint256 totalPermanent,
        uint256 remainingGlobal,
        uint256 remainingTerm,
        uint256 remainingPermanent
    ) {
        totalAll           = s.totalStakedAll;
        totalTerm          = s.totalStakedTerm;
        totalPermanent     = s.totalStakedPermanent;
        remainingGlobal    = GLOBAL_CAP  > totalAll       ? GLOBAL_CAP  - totalAll       : 0;
        remainingTerm      = TERM_CAP    > totalTerm      ? TERM_CAP    - totalTerm      : 0;
        remainingPermanent = PERM_CAP    > totalPermanent ? PERM_CAP    - totalPermanent : 0;
    }

    function pendingRewardsView(address collection, address owner, uint256 tokenId)
        external
        view
        onlyRegistered(collection)
        returns (uint256)
    {
        return s.pendingRewards(collection, owner, tokenId, numberOfBlocksPerRewardUnit);
    }

    function collectionCount() external view returns (uint256) {
        return registeredCollections.length;
    }

    /* ========= ERC721 Receiver + Pause + UUPS ========= */

    /// @notice Only accept NFTs from registered collections.
    function onERC721Received(address, address, uint256, bytes calldata)
        external
        view
        override
        returns (bytes4)
    {
        if (registeredIndex[msg.sender] == 0) revert NotERC721Sender();
        return this.onERC721Received.selector;
    }

    function pause() external onlyRole(CONTRACT_ADMIN_ROLE) { _pause(); }
    function unpause() external onlyRole(CONTRACT_ADMIN_ROLE) { _unpause(); }

    function _authorizeUpgrade(address) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}

    // storage gap for future upgrades
    uint256[50] private __gap;
}
