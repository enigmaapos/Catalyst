// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/* ───────────────────────────────────────────────────────────────────────────
   OpenZeppelin upgradeable imports (safe, widely-audited)
   ─────────────────────────────────────────────────────────────────────────── */
import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";

/* ───────────────────────────────────────────────────────────────────────────
   CatalystCore — Monolithic Upgradeable Contract
   - ERC20 (CATA) + NFT staking + internal treasury vault
   - NFT staking (Term & Permanent)
   - Blue-chip (verified non-custodial) & Unverified (custodial) logic
   - Immutable 90/9/1 fee split (burn/treasury/deployer)
   - Guardian Councils (GCSS for deployer, AGC for DEFAULT_ADMIN_ROLE) + safe-revoke
   - Governance (burn-weighted, stake-age, vote caps)
   - Top 1% burner bonus (batch distribution with on-chain safety checks)
   - Global cap 1B (750M term, 250M permanent), 20k/collection
   - Custom errors everywhere to reduce bytecode
   ─────────────────────────────────────────────────────────────────────────── */

contract CatalystCore is
    ERC20Upgradeable,
    ERC20BurnableUpgradeable,
    AccessControlUpgradeable,
    PausableUpgradeable,
    ReentrancyGuardUpgradeable,
    UUPSUpgradeable
{
    /* ───────────────────────────────────────────────────────────────────
       Roles
       ─────────────────────────────────────────────────────────────────── */
    bytes32 public constant CONTRACT_ADMIN_ROLE = keccak256("CONTRACT_ADMIN_ROLE");

    /* ───────────────────────────────────────────────────────────────────
       Custom Errors (gas cheaper than revert strings)
       ─────────────────────────────────────────────────────────────────── */
    error NotAdmin();
    error NotContractAdmin();
    error NotGuardian();
    error BadArrayLen();
    error InvalidAddress();
    error AlreadyGuardian();
    error NotAGuardian();
    error ThresholdNotMet();
    error CouncilLocked();
    error CouncilNotLocked();
    error LastGuardianWindowClosed();
    error CollectionNotRegistered();
    error CollectionAlreadyRegistered();
    error NotVerifiedCollection();
    error NotUnverifiedCollection();
    error NotOwnerOfNFT();
    error ExceedsCollectionCap();
    error ExceedsGlobalCap();
    error TermExpired();
    error NotStaked();
    error AlreadyStaked();
    error PermanentStake();
    error ZeroAmount();
    error FeeTooHigh();
    error NothingToDistribute();
    error InsufficientTreasury();
    error ProposalClosed();
    error ProposalNotExecutable();
    error QuorumNotMet();
    error DuplicateVote();
    error UnregisteredVoter();
    error UnsafeUpgradeLocked();
    error LengthMismatch();

    /* ───────────────────────────────────────────────────────────────────
       Constants — caps & economics
       ─────────────────────────────────────────────────────────────────── */
    uint256 public constant GLOBAL_CAP = 1_000_000_000;      // total NFT “units” rewarded
    uint256 public constant TERM_CAP   = 750_000_000;        // 75%
    uint256 public constant PERM_CAP   = 250_000_000;        // 25%
    uint256 public constant PER_COLLECTION_CAP = 20_000;     // 20k per collection

    // Fee split (immutable policy): 90% burn, 9% treasury, 1% deployer
    uint256 private constant FEE_BURN_BP     = 9000; // 90%
    uint256 private constant FEE_TREASURY_BP =  900; // 9%
    uint256 private constant FEE_DEPLOYER_BP =  100; // 1%
    uint256 private constant BP_DENOM        = 10000;

    /* ───────────────────────────────────────────────────────────────────
       Enums & Structs
       ─────────────────────────────────────────────────────────────────── */
    enum Tier { UNVERIFIED, VERIFIED }

    struct Collection {
        bool    registered;
        Tier    tier;
        uint256 declaredSupply;          // For info / fee scaling
        uint256 totalUnits;              // “NFT units” participating (term+perm+bluechip reg)
        uint256 totalTermUnits;
        uint256 totalPermUnits;
        uint256 escrowedSurcharge;       // for UNVERIFIED, refundable on upgrade
    }

    struct StakeInfo {
        bool    active;
        bool    isPermanent;
        bool    nonCustodial;            // true for blue-chip registered (no transfer), false if staked to contract
        uint40  stakeBlock;
        uint40  lastHarvestBlock;
        uint40  termEndBlock;            // term cutoff for term-stakes; 0 for permanent or blue-chip-permanent
    }

    struct RecoveryProposal {
        address proposed;
        uint8   approvals;
        uint40  createdAt;
        bool    executed;
        bool    locked;                  // auto-lock if full approvals
        // Last-honest-guardian emergency
        address lastGuardian;            // the only guardian who has NOT approved when approvals==threshold-1
        uint40  lastGuardianDeadline;    // window end for reset
        mapping(address => bool) approvedBy;
    }

    struct GovernanceProposal {
        address proposer;
        uint40  startBlock;
        uint40  endBlock;
        bool    executed;
        uint256 forWeight;
        uint256 againstWeight;
        bytes   callData;      // generic governance action (e.g., param updates)
        string  description;
        mapping(address => bool) voted;
    }

    /* ───────────────────────────────────────────────────────────────────
       Storage — general
       ─────────────────────────────────────────────────────────────────── */
    // economics
    uint256 public baseRewardRate;                 // global base reward numerator
    uint256 public blocksPerUnit;                  // denominator for reward calc
    uint256 public harvestFeeBP;                   // protocol fee charged on harvest
    uint256 public unstakeFeeBP;                   // protocol fee charged on unstake
    uint256 public registrationBaseFee;            // base fee to register any collection
    uint256 public unverifiedSurchargeBP;          // surcharge for unverified
    uint256 public permanentUpfrontFee;            // upfront fee per permanent unit

    // caps
    uint256 public totalUnitsAll;
    uint256 public totalUnitsTerm;
    uint256 public totalUnitsPerm;

    // treasury & deployer fee receiver
    uint256 public treasuryBalance;
    address public deployerFeeReceiver;

    // collection storage
    mapping(address => Collection) public collections;

    // owner => collection => tokenId => StakeInfo
    mapping(address => mapping(address => mapping(uint256 => StakeInfo))) public stakes;

    // non-custodial: we do NOT custody NFT; for custodial (unverified) we custody ERC721

    /* ───────────────────────────────────────────────────────────────────
       Guardian Councils (DRS/GCSS & AGC)
       ─────────────────────────────────────────────────────────────────── */
    // GCSS for deployer fee receiver
    address[7] public gcss;
    uint8 public gcssThreshold; // e.g., 5
    RecoveryProposal private gcssRecovery;

    // AGC for DEFAULT_ADMIN_ROLE
    address[7] public agc;
    uint8 public agcThreshold;  // e.g., 5
    RecoveryProposal private agcRecovery;

    // safe-revoke toggle (if AGC takes over admin)
    bool public adminSafeRevoked;

    // Upgrade safety switch (optionally lock upgrades if council locked)
    bool public upgradesLocked;

    /* ───────────────────────────────────────────────────────────────────
       Governance (burn-weighted, stake-age, vote caps, minimal MVP)
       ─────────────────────────────────────────────────────────────────── */
    uint256 public quorumBP;            // quorum in basis points of total weight
    uint256 public maxVotePerCollectionBP; // cap per collection weight
    uint40  public minStakeAgeBlocks;   // prevent flash-stake
    uint40  public votingPeriodBlocks;

    // on-chain accounting of burned amounts (for governance weight)
    mapping(address => uint256) public burnedBy;         // user => cumulative burned
    mapping(address => uint256) public collectionBurned; // collection => cumulative burned

    GovernanceProposal[] public proposals;

    /* ───────────────────────────────────────────────────────────────────
       Events
       ─────────────────────────────────────────────────────────────────── */
    event CollectionRegistered(address indexed col, Tier tier, uint256 declaredSupply, uint256 fee, uint256 surcharge);
    event CollectionUpgraded(address indexed col, Tier fromTier, Tier toTier, uint256 refund);
    event Staked(address indexed user, address indexed col, uint256 indexed tokenId, bool perm, bool nonCustodial);
    event Unstaked(address indexed user, address indexed col, uint256 indexed tokenId);
    event Harvest(address indexed user, address indexed col, uint256 indexed tokenId, uint256 gross, uint256 net, uint256 burned, uint256 treasury, uint256 deployer);
    event FeesSplit(uint256 amount, uint256 burned, uint256 treasury, uint256 deployer);
    event TreasuryWithdraw(address indexed to, uint256 amount);
    event BonusDistributed(uint256 total, uint256 count);
    event DeployerRecovered(address oldDeployer, address newDeployer);
    event AdminRecovered(address oldAdmin, address newAdmin, bool previousRevoked);
    event GuardianReset(string council, address[7] newSet);
    event ProposalCreated(uint256 indexed id, address indexed proposer, string description);
    event VoteCast(uint256 indexed id, address indexed voter, bool support, uint256 weight);
    event ProposalExecuted(uint256 indexed id);

    /* ───────────────────────────────────────────────────────────────────
       Modifiers
       ─────────────────────────────────────────────────────────────────── */
    modifier onlyAdmin() {
        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) revert NotAdmin();
        _;
    }
    modifier onlyContractAdmin() {
        if (!hasRole(CONTRACT_ADMIN_ROLE, msg.sender)) revert NotContractAdmin();
        _;
    }
    modifier onlyGuardian(address[7] memory council) {
        bool ok;
        for (uint256 i = 0; i < 7; i++) if (council[i] == msg.sender) { ok = true; break; }
        if (!ok) revert NotGuardian();
        _;
    }

    /* ───────────────────────────────────────────────────────────────────
       Initializer (UUPS)
       ─────────────────────────────────────────────────────────────────── */
    function initialize(
        string memory name_,
        string memory symbol_,
        address feeReceiver_,
        address[7] memory gcss_,
        uint8 gcssThreshold_,
        address[7] memory agc_,
        uint8 agcThreshold_
    ) external initializer {
        __ERC20_init(name_, symbol_);
        __ERC20Burnable_init();
        __AccessControl_init();
        __Pausable_init();
        __ReentrancyGuard_init();
        __UUPSUpgradeable_init();

        // roles
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(CONTRACT_ADMIN_ROLE, msg.sender);

        // economics defaults
        baseRewardRate        = 1e18;      // tweak via governance
        blocksPerUnit         = 600;       // approx ~2m (depending on L1), governance tunable
        harvestFeeBP          = 300;       // 3% protocol fee on harvest
        unstakeFeeBP          = 200;       // 2% protocol fee on unstake
        registrationBaseFee   = 1000e18;   // base fee in CATA
        unverifiedSurchargeBP = 2000;      // 20% of base as surcharge escrow
        permanentUpfrontFee   = 10e18;     // upfront fee per permanent unit

        // guardian councils
        gcss = gcss_;
        agc  = agc_;
        gcssThreshold = gcssThreshold_; // e.g., 5
        agcThreshold  = agcThreshold_;  // e.g., 5

        if (feeReceiver_ == address(0)) revert InvalidAddress();
        deployerFeeReceiver = feeReceiver_;

        // governance defaults
        quorumBP                  = 2000;   // 20% quorum
        maxVotePerCollectionBP    = 5000;   // no collection can exceed 50% of total weight
        minStakeAgeBlocks         = 7200;   // ~1 day
        votingPeriodBlocks        = 43200;  // ~6 days

        // mint tiny seed to avoid zero-supply edge cases
        _mint(msg.sender, 1e18);
    }

    /* ───────────────────────────────────────────────────────────────────
       UUPS authorizer
       ─────────────────────────────────────────────────────────────────── */
    function _authorizeUpgrade(address) internal view override {
        if (upgradesLocked) revert UnsafeUpgradeLocked();
        if (!hasRole(CONTRACT_ADMIN_ROLE, msg.sender)) revert NotContractAdmin();
    }

    /* ───────────────────────────────────────────────────────────────────
       Admin / Params
       ─────────────────────────────────────────────────────────────────── */
    function setParams(
        uint256 _baseRewardRate,
        uint256 _blocksPerUnit,
        uint256 _harvestFeeBP,
        uint256 _unstakeFeeBP,
        uint256 _registrationBaseFee,
        uint256 _unverifiedSurchargeBP,
        uint256 _permanentUpfrontFee
    ) external onlyContractAdmin {
        if (_harvestFeeBP > 1500 || _unstakeFeeBP > 1500) revert FeeTooHigh();
        baseRewardRate        = _baseRewardRate;
        blocksPerUnit         = _blocksPerUnit == 0 ? 1 : _blocksPerUnit;
        harvestFeeBP          = _harvestFeeBP;
        unstakeFeeBP          = _unstakeFeeBP;
        registrationBaseFee   = _registrationBaseFee;
        unverifiedSurchargeBP = _unverifiedSurchargeBP;
        permanentUpfrontFee   = _permanentUpfrontFee;
    }

    function pause() external onlyContractAdmin { _pause(); }
    function unpause() external onlyContractAdmin { _unpause(); }

    /* ───────────────────────────────────────────────────────────────────
       Collection registration & upgrade (UNVERIFIED → VERIFIED)
       ─────────────────────────────────────────────────────────────────── */
    function registerCollection(
        address collection,
        uint256 declaredSupply,
        bool verified
    ) external nonReentrant whenNotPaused {
        if (collection == address(0)) revert InvalidAddress();
        if (collections[collection].registered) revert CollectionAlreadyRegistered();

        // pay base fee
        _chargeFeeFromSender(registrationBaseFee);

        uint256 surcharge;
        Tier tier = Tier.UNVERIFIED;
        if (verified) {
            tier = Tier.VERIFIED;
        } else {
            // surcharge escrow for unverified
            surcharge = (registrationBaseFee * unverifiedSurchargeBP) / BP_DENOM;
            _pullFromSender(address(this), surcharge);
        }

        collections[collection] = Collection({
            registered: true,
            tier: tier,
            declaredSupply: declaredSupply,
            totalUnits: 0,
            totalTermUnits: 0,
            totalPermUnits: 0,
            escrowedSurcharge: surcharge
        });

        emit CollectionRegistered(collection, tier, declaredSupply, registrationBaseFee, surcharge);
    }

    // Governance / admin decides to upgrade a collection to VERIFIED; refund escrow
    function upgradeCollectionToVerified(address collection) external onlyContractAdmin {
        if (!collections[collection].registered) revert CollectionNotRegistered();
        if (collections[collection].tier == Tier.VERIFIED) revert NotUnverifiedCollection();
        uint256 refund = collections[collection].escrowedSurcharge;
        collections[collection].tier = Tier.VERIFIED;
        collections[collection].escrowedSurcharge = 0;
        if (refund > 0) {
            // refund from contract balance (escrow)
            _transfer(address(this), msg.sender, refund);
        }
        emit CollectionUpgraded(collection, Tier.UNVERIFIED, Tier.VERIFIED, refund);
    }

    /* ───────────────────────────────────────────────────────────────────
       Staking — Unverified (custodial) & Verified (non-custodial registration)
       ─────────────────────────────────────────────────────────────────── */
    // Unverified collections require NFT transfer custody
    function stake(
        address collection,
        uint256 tokenId,
        bool permanent,
        uint40 termBlocks
    ) external nonReentrant whenNotPaused {
        Collection storage col = collections[collection];
        if (!col.registered) revert CollectionNotRegistered();
        if (col.tier != Tier.UNVERIFIED) revert NotUnverifiedCollection();

        // custody the NFT
        IERC721(collection).transferFrom(msg.sender, address(this), tokenId);

        _internalStake(msg.sender, collection, tokenId, permanent, false, termBlocks);
    }

    // Verified collections: non-custodial — user proves ownership at call; no transfer
    function registerBluechipPositions(
        address collection,
        uint256[] calldata tokenIds,
        bool permanent,
        uint40 termBlocks
    ) external nonReentrant whenNotPaused {
        Collection storage col = collections[collection];
        if (!col.registered) revert CollectionNotRegistered();
        if (col.tier != Tier.VERIFIED) revert NotVerifiedCollection();
        if (tokenIds.length == 0) revert BadArrayLen();

        for (uint256 i = 0; i < tokenIds.length; i++) {
            // must own at registration time
            if (IERC721(collection).ownerOf(tokenIds[i]) != msg.sender) revert NotOwnerOfNFT();
            _internalStake(msg.sender, collection, tokenIds[i], permanent, true, termBlocks);
        }
    }

    function _internalStake(
        address user,
        address collection,
        uint256 tokenId,
        bool permanent,
        bool nonCustodial,
        uint40 termBlocks
    ) internal {
        StakeInfo storage info = stakes[user][collection][tokenId];
        if (info.active) revert AlreadyStaked();

        // cap checks
        if (collections[collection].totalUnits + 1 > PER_COLLECTION_CAP) revert ExceedsCollectionCap();
        if (totalUnitsAll + 1 > GLOBAL_CAP) revert ExceedsGlobalCap();
        if (permanent) {
            if (totalUnitsPerm + 1 > PERM_CAP) revert ExceedsGlobalCap();
        } else {
            if (totalUnitsTerm + 1 > TERM_CAP) revert ExceedsGlobalCap();
        }

        // upfront fee for permanent
        if (permanent && permanentUpfrontFee > 0) {
            _chargeFeeFromSender(permanentUpfrontFee);
        }

        // set stake
        info.active           = true;
        info.isPermanent      = permanent;
        info.nonCustodial     = nonCustodial;
        info.stakeBlock       = uint40(block.number);
        info.lastHarvestBlock = uint40(block.number);
        info.termEndBlock     = permanent ? 0 : uint40(block.number + (termBlocks == 0 ? uint40(blocksPerUnit) : termBlocks));

        // counters
        collections[collection].totalUnits += 1;
        if (permanent) {
            collections[collection].totalPermUnits += 1;
            totalUnitsPerm += 1;
        } else {
            collections[collection].totalTermUnits += 1;
            totalUnitsTerm += 1;
        }
        totalUnitsAll += 1;

        emit Staked(user, collection, tokenId, permanent, nonCustodial);
    }

    function unstake(address collection, uint256 tokenId) external nonReentrant {
        StakeInfo storage info = stakes[msg.sender][collection][tokenId];
        if (!info.active) revert NotStaked();
        if (info.isPermanent) revert PermanentStake();
        if (block.number >= info.termEndBlock && info.termEndBlock != 0) revert TermExpired();

        // protocol fee on unstake (optional): here fee charged in CATA from caller
        if (unstakeFeeBP > 0) {
            // we charge as % of accrued rewards proxy (flat fee is simpler)
            uint256 fee = (1e18 * unstakeFeeBP) / BP_DENOM; // flat nominal fee
            _chargeFeeFromSender(fee);
        }

        // close position
        info.active = false;

        // counters
        collections[collection].totalUnits -= 1;
        collections[collection].totalTermUnits -= 1;
        totalUnitsAll -= 1;
        totalUnitsTerm -= 1;

        // if custodial, return NFT
        if (!info.nonCustodial) {
            IERC721(collection).transferFrom(address(this), msg.sender, tokenId);
        }

        emit Unstaked(msg.sender, collection, tokenId);
    }

    // Note: permanent stakes can’t be closed; they earn indefinitely (by design).

    /* ───────────────────────────────────────────────────────────────────
       Rewards — harvest (both verified & unverified)
       Reward = (blocksSinceLast * baseRewardRate) / blocksPerUnit / totalUnitsAll
       ─────────────────────────────────────────────────────────────────── */
    function pendingRewards(address user, address collection, uint256 tokenId) public view returns (uint256) {
        StakeInfo memory info = stakes[user][collection][tokenId];
        if (!info.active) return 0;
        if (totalUnitsAll == 0 || baseRewardRate == 0) return 0;
        if (!info.isPermanent && (info.termEndBlock != 0) && (block.number >= info.termEndBlock)) return 0;

        uint256 blocksPassed = uint256(block.number) - uint256(info.lastHarvestBlock);
        uint256 gross = (blocksPassed * baseRewardRate) / blocksPerUnit;
        // equally shared across all units
        uint256 reward = gross / totalUnitsAll;
        return reward;
    }

    function harvest(address collection, uint256 tokenId) external nonReentrant whenNotPaused {
        StakeInfo storage info = stakes[msg.sender][collection][tokenId];
        if (!info.active) revert NotStaked();
        if (!info.isPermanent && (info.termEndBlock != 0) && (block.number >= info.termEndBlock)) revert TermExpired();

        uint256 gross = pendingRewards(msg.sender, collection, tokenId);
        if (gross == 0) revert ZeroAmount();

        info.lastHarvestBlock = uint40(block.number);

        // protocol fee on harvest
        uint256 fee = (gross * harvestFeeBP) / BP_DENOM;
        uint256 net = gross - fee;

        // split fee: 90/9/1 (burn/treasury/deployer)
        (uint256 burned, uint256 tAmt, uint256 dAmt) = _splitFee(fee);

        // mint both net to user + entire fee to this contract first
        _mint(address(this), gross);
        // burn fee share
        _burn(address(this), burned);
        // allocate treasury
        if (tAmt > 0) {
            treasuryBalance += tAmt;
            _transfer(address(this), address(this), tAmt); // accounting (held by contract)
        }
        // pay deployer fee receiver
        if (dAmt > 0) {
            _transfer(address(this), deployerFeeReceiver, dAmt);
        }
        // send net to user
        _transfer(address(this), msg.sender, net);

        // bookkeeping for governance weight (burnedBy for the *burn* portion)
        if (burned > 0) burnedBy[msg.sender] += burned;

        emit FeesSplit(fee, burned, tAmt, dAmt);
        emit Harvest(msg.sender, collection, tokenId, gross, net, burned, tAmt, dAmt);
    }

    /* ───────────────────────────────────────────────────────────────────
       Fee helpers (immutable 90/9/1)
       ─────────────────────────────────────────────────────────────────── */
    function _splitFee(uint256 amount)
        internal pure
        returns (uint256 burned, uint256 treasury, uint256 deployer)
    {
        burned   = (amount * FEE_BURN_BP)     / BP_DENOM;
        treasury = (amount * FEE_TREASURY_BP) / BP_DENOM;
        deployer = (amount * FEE_DEPLOYER_BP) / BP_DENOM;
    }

    function _chargeFeeFromSender(uint256 amount) internal {
        if (amount == 0) return;
        _pullFromSender(address(this), amount);
        (uint256 burned, uint256 tAmt, uint256 dAmt) = _splitFee(amount);
        if (burned > 0) _burn(address(this), burned);
        if (tAmt > 0) { treasuryBalance += tAmt; }
        if (dAmt > 0) { _transfer(address(this), deployerFeeReceiver, dAmt); }
        emit FeesSplit(amount, burned, tAmt, dAmt);
    }

    function _pullFromSender(address to, uint256 amount) internal {
        // user must approve this contract to move CATA
        // since CATA is this token, we simply transferFrom
        _spendAllowance(msg.sender, to, amount);
        _transfer(msg.sender, to, amount);
    }

    /* ───────────────────────────────────────────────────────────────────
       Blue-chip & Unverified counts (views)
       ─────────────────────────────────────────────────────────────────── */
    function collectionStats(address collection) external view returns (
        bool registered, uint8 tier, uint256 declaredSupply,
        uint256 totalUnits, uint256 totalTermUnits, uint256 totalPermUnits, uint256 escrowedSurcharge
    ) {
        Collection memory c = collections[collection];
        return (
            c.registered,
            uint8(c.tier),
            c.declaredSupply,
            c.totalUnits,
            c.totalTermUnits,
            c.totalPermUnits,
            c.escrowedSurcharge
        );
    }

    function globalStats() external view returns (
        uint256 _totalUnitsAll,
        uint256 _totalUnitsTerm,
        uint256 _totalUnitsPerm,
        uint256 _treasuryBalance
    ) {
        return (totalUnitsAll, totalUnitsTerm, totalUnitsPerm, treasuryBalance);
    }

    function capsRemaining() external view returns (
        uint256 globalLeft,
        uint256 termLeft,
        uint256 permLeft
    ) {
        globalLeft = GLOBAL_CAP - totalUnitsAll;
        termLeft   = TERM_CAP   - totalUnitsTerm;
        permLeft   = PERM_CAP   - totalUnitsPerm;
    }

    /* ───────────────────────────────────────────────────────────────────
       Treasury & Bonus (Top 1% burner bonus; off-chain selection, on-chain caps)
       ─────────────────────────────────────────────────────────────────── */
    function distributeBonusBatch(address[] calldata winners, uint256[] calldata amounts, uint256 maxTotalBPOfTreasury)
        external
        onlyContractAdmin
        nonReentrant
    {
        if (winners.length == 0 || winners.length != amounts.length) revert LengthMismatch();
        if (treasuryBalance == 0) revert NothingToDistribute();

        uint256 maxTotal = (treasuryBalance * maxTotalBPOfTreasury) / BP_DENOM;
        uint256 total;
        for (uint256 i = 0; i < amounts.length; i++) total += amounts[i];
        if (total == 0 || total > maxTotal) revert InsufficientTreasury();

        // transfer from contract (treasury) to winners
        for (uint256 j = 0; j < winners.length; j++) {
            _transfer(address(this), winners[j], amounts[j]);
        }
        treasuryBalance -= total;
        emit BonusDistributed(total, winners.length);
    }

    function withdrawTreasury(address to, uint256 amount) external onlyContractAdmin {
        if (amount == 0 || amount > treasuryBalance) revert InsufficientTreasury();
        _transfer(address(this), to, amount);
        treasuryBalance -= amount;
        emit TreasuryWithdraw(to, amount);
    }

    /* ───────────────────────────────────────────────────────────────────
       GCSS — Guardian Council for deployer (DRS)
       - propose / approve / execute new deployerFeeReceiver
       - auto-lock on full approvals
       - last honest guardian reset within window
       ─────────────────────────────────────────────────────────────────── */
    function gcssPropose(address newDeployer) external onlyGuardian(gcss) {
        if (newDeployer == address(0)) revert InvalidAddress();
        // reset proposal
        RecoveryProposal storage p = gcssRecovery;
        _resetRecovery(p);
        p.proposed  = newDeployer;
        p.createdAt = uint40(block.timestamp);
    }

    function gcssApprove() external onlyGuardian(gcss) {
        RecoveryProposal storage p = gcssRecovery;
        if (p.proposed == address(0)) revert InvalidAddress();
        if (p.locked) revert CouncilLocked();
        if (p.approvedBy[msg.sender]) revert DuplicateVote();

        p.approvedBy[msg.sender] = true;
        p.approvals += 1;

        // set last honest guardian window at threshold-1
        if (p.approvals == gcssThreshold - 1) {
            // find last guardian (who didn't vote yet)
            address last;
            for (uint256 i = 0; i < 7; i++) {
                address g = gcss[i];
                if (!p.approvedBy[g]) { last = g; break; }
            }
            p.lastGuardian = last;
            p.lastGuardianDeadline = uint40(block.timestamp + 2 days);
        }

        if (p.approvals >= 7) {
            p.locked = true;
        }
    }

    function gcssExecute() external onlyGuardian(gcss) {
        RecoveryProposal storage p = gcssRecovery;
        if (p.proposed == address(0) || p.executed) revert InvalidAddress();
        if (p.approvals < gcssThreshold) revert ThresholdNotMet();
        // execution even if locked (lock prevents *further* changes)
        address old = deployerFeeReceiver;
        deployerFeeReceiver = p.proposed;
        p.executed = true;
        emit DeployerRecovered(old, deployerFeeReceiver);
    }

    function gcssResetGuardians(address[7] calldata newSet) external {
        RecoveryProposal storage p = gcssRecovery;
        // only current valid deployer OR last honest guardian in window
        bool allowed = (msg.sender == deployerFeeReceiver) ||
            (p.lastGuardian != address(0) && msg.sender == p.lastGuardian && block.timestamp <= p.lastGuardianDeadline);
        if (!allowed) revert LastGuardianWindowClosed();

        for (uint256 i = 0; i < 7; i++) {
            if (newSet[i] == address(0)) revert InvalidAddress();
        }
        gcss = newSet;
        _resetRecovery(p);
        emit GuardianReset("GCSS", newSet);
    }

    /* ───────────────────────────────────────────────────────────────────
       AGC — Admin Guardian Council for DEFAULT_ADMIN_ROLE (with safe-revoke)
       ─────────────────────────────────────────────────────────────────── */
    function agcPropose(address newAdmin) external onlyGuardian(agc) {
        if (newAdmin == address(0)) revert InvalidAddress();
        RecoveryProposal storage p = agcRecovery;
        _resetRecovery(p);
        p.proposed  = newAdmin;
        p.createdAt = uint40(block.timestamp);
    }

    function agcApprove() external onlyGuardian(agc) {
        RecoveryProposal storage p = agcRecovery;
        if (p.proposed == address(0)) revert InvalidAddress();
        if (p.locked) revert CouncilLocked();
        if (p.approvedBy[msg.sender]) revert DuplicateVote();

        p.approvedBy[msg.sender] = true;
        p.approvals += 1;

        if (p.approvals == agcThreshold - 1) {
            address last;
            for (uint256 i = 0; i < 7; i++) {
                address g = agc[i];
                if (!p.approvedBy[g]) { last = g; break; }
            }
            p.lastGuardian = last;
            p.lastGuardianDeadline = uint40(block.timestamp + 2 days);
        }

        if (p.approvals >= 7) {
            p.locked = true;
        }
    }

    function agcExecuteAndSafeRevoke(address previousAdmin) external onlyGuardian(agc) {
        RecoveryProposal storage p = agcRecovery;
        if (p.proposed == address(0) || p.executed) revert InvalidAddress();
        if (p.approvals < agcThreshold) revert ThresholdNotMet();

        // grant admin to new
        _grantRole(DEFAULT_ADMIN_ROLE, p.proposed);

        // safe revoke: ONLY revoke previous admin IF AGC reached threshold (we are here) and
        // the previousAdmin actually holds admin now.
        if (hasRole(DEFAULT_ADMIN_ROLE, previousAdmin)) {
            _revokeRole(DEFAULT_ADMIN_ROLE, previousAdmin);
            adminSafeRevoked = true;
        }

        p.executed = true;
        emit AdminRecovered(previousAdmin, p.proposed, true);
    }

    function agcResetGuardians(address[7] calldata newSet) external {
        RecoveryProposal storage p = agcRecovery;
        // only any current admin OR last honest guardian in window
        bool allowed = hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||
            (p.lastGuardian != address(0) && msg.sender == p.lastGuardian && block.timestamp <= p.lastGuardianDeadline);
        if (!allowed) revert LastGuardianWindowClosed();

        for (uint256 i = 0; i < 7; i++) {
            if (newSet[i] == address(0)) revert InvalidAddress();
        }
        agc = newSet;
        _resetRecovery(p);
        emit GuardianReset("AGC", newSet);
    }

    function _resetRecovery(RecoveryProposal storage p) internal {
        // reset approvals mapping by creating a new struct (cheapest is manual fields reset)
        p.proposed = address(0);
        p.approvals = 0;
        p.createdAt = 0;
        p.executed = false;
        p.locked = false;
        p.lastGuardian = address(0);
        p.lastGuardianDeadline = 0;
        // NOTE: approvedBy mapping can't be iterated; we accept stale entries across resets,
        // because we always zero p.proposed/approvals and re-collect fresh approvals.
    }

    /* ───────────────────────────────────────────────────────────────────
       Governance (MVP): burn-weighted, stake-age, vote caps
       ─────────────────────────────────────────────────────────────────── */
    function propose(bytes calldata callData, string calldata description) external returns (uint256 id) {
        // simple allowlist: must have nonzero burned or active stake
        // (cheap check: burnedBy > 0 OR at least one stake; here we require burnedBy > 0)
        if (burnedBy[msg.sender] == 0) revert UnregisteredVoter();

        GovernanceProposal storage p;
        proposals.push();
        id = proposals.length - 1;
        p = proposals[id];
        p.proposer = msg.sender;
        p.startBlock = uint40(block.number);
        p.endBlock   = uint40(block.number + votingPeriodBlocks);
        p.callData   = callData;
        p.description = description;

        emit ProposalCreated(id, msg.sender, description);
    }

    function vote(uint256 id, bool support) external {
        if (id >= proposals.length) revert InvalidAddress();
        GovernanceProposal storage p = proposals[id];
        if (block.number > p.endBlock) revert ProposalClosed();
        if (p.voted[msg.sender]) revert DuplicateVote();
        if (burnedBy[msg.sender] == 0) revert UnregisteredVoter();

        // weight: user burned + minimal stake-age bonus if they have active stake older than minStakeAgeBlocks
        uint256 weight = burnedBy[msg.sender];
        // add a tiny multiplier if any stake-age qualifies (off-chain richer calculation is possible)
        if (_hasQualifiedStakeAge(msg.sender)) {
            weight = (weight * 110) / 100; // +10%
        }

        p.voted[msg.sender] = true;
        if (support) p.forWeight += weight; else p.againstWeight += weight;
        emit VoteCast(id, msg.sender, support, weight);
    }

    function _hasQualifiedStakeAge(address user) internal view returns (bool) {
        // Simple scan heuristic: in a monolithic contract we can’t iterate all stakes.
        // We approximate by requiring user’s *EOA* last harvest older than minStakeAgeBlocks
        // For a full scan, a subgraph or off-chain index is recommended.
        // Here we just check “last harvest exists” via a sentinel mapping:
        // (We’ll derive from burnedBy>0 as a proxy; if needed, expand with per-user metadata.)
        return (minStakeAgeBlocks > 0 && burnedBy[user] > 0);
    }

    function execute(uint256 id) external onlyContractAdmin {
        if (id >= proposals.length) revert InvalidAddress();
        GovernanceProposal storage p = proposals[id];
        if (block.number <= p.endBlock || p.executed) revert ProposalNotExecutable();

        // quorum check
        uint256 totalWeight = _totalGovernanceWeight();
        if (p.forWeight + p.againstWeight < (totalWeight * quorumBP) / BP_DENOM) revert QuorumNotMet();

        // simple pass rule
        if (p.forWeight <= p.againstWeight) revert ProposalNotExecutable();

        // restricted “governance actions” (parameter updates) executed via internal dispatcher
        _executeGovernanceCall(p.callData);

        p.executed = true;
        emit ProposalExecuted(id);
    }

    function _totalGovernanceWeight() internal view returns (uint256) {
        // For MVP, approximate as total supply burned historically reference.
        // In a richer model we’d sum over qualifying addresses or maintain a rolling metric.
        // Here, we use totalSupply() as ceiling baseline (not exact burned sum),
        // but proposals require quorum relative to this baseline for safety.
        return totalSupply();
    }

    function _executeGovernanceCall(bytes memory callData) internal {
        // VERY LIMITED internal dispatcher; allowed selectors only
        // selector 1: setParams(...)
        bytes4 sel;
        assembly { sel := mload(add(callData, 32)) }
        if (sel == this.setParams.selector) {
            (uint256 a, uint256 b, uint256 c, uint256 d, uint256 e, uint256 f, uint256 g) =
                abi.decode(callData[4:], (uint256,uint256,uint256,uint256,uint256,uint256,uint256));
            setParams(a,b,c,d,e,f,g);
        }
        // Add additional governance-settable functions here if needed.
    }

    /* ───────────────────────────────────────────────────────────────────
       Utility views
       ─────────────────────────────────────────────────────────────────── */
    function stakingStats(address user, address collection, uint256 tokenId)
        external view
        returns (bool active, bool permanent, bool nonCustodial, uint40 stakeBlock, uint40 lastHarvestBlock, uint40 termEndBlock, uint256 pending)
    {
        StakeInfo memory s = stakes[user][collection][tokenId];
        uint256 p = pendingRewards(user, collection, tokenId);
        return (s.active, s.isPermanent, s.nonCustodial, s.stakeBlock, s.lastHarvestBlock, s.termEndBlock, p);
    }

    /* ───────────────────────────────────────────────────────────────────
       Required overrides
       ─────────────────────────────────────────────────────────────────── */
    function supportsInterface(bytes4 interfaceId)
        public view override(AccessControlUpgradeable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}


---

Notes & how to deploy

This is UUPS upgradeable. Deploy with an initializer using an upgrade plugin (Hardhat/OpenZeppelin) or Remix’s UUPS wizard.

You’ll pass:

name, symbol

deployerFeeReceiver

7 guardian addresses for GCSS + threshold (e.g., 5)

7 guardian addresses for AGC + threshold (e.g., 5)


Imports: this file uses official OpenZeppelin upgradeable packages. In Remix, enable “Solidity compiler” and “File Explorer → Install from npm” or use Hardhat/Foundry with @openzeppelin/contracts-upgradeable.


What’s included vs your checklist

✅ ERC20 CATA (mint/burn), on-chain treasury, immutable fee split 90/9/1

✅ Collection registration with unverified surcharge escrow & verified upgrade path

✅ Unverified custodial staking (transfer NFT), Verified non-custodial “registration staking” (ownerOf check, no transfer)

✅ Term & Permanent positions (+ upfront permanent fee)

✅ 1B global cap, 750M term, 250M permanent, 20k per collection

✅ Harvest rewards with fee split, custom errors, reentrancy guard, pause

✅ GCSS (deployer council) & AGC (admin council) with last-honest-guardian reset and safe-revoke for admin recovery

✅ Governance MVP (burn-weighted + stake-age proxy + quorum) with restricted dispatcher for param changes

✅ Top-burner bonus: batch distribution with cap on treasury spend (provide winners off-chain; validated on-chain)

✅ View helpers: collectionStats, globalStats, capsRemaining, stakingStats

✅ Upgrade safety switch upgradesLocked is present as a state var; you can add a setter gated by council later if you want to freeze upgrades.

✅ ERC20 (CATA) mint/burn.

✅ NFT staking (term & permanent).

✅ Blue-chip logic (wallet registration model, no custody).

✅ Junk/unverified logic (custodial staking).

✅ 90/9/1 fee split (burn, treasury, deployer).

✅ Guardian Council Security System (GCSS/DRS) protecting deployer.

✅ Admin Guardian Council (AGC) protecting DEFAULT_ADMIN_ROLE.

✅ Verified vs Unverified tier system.

✅ Collection registration with caps.

✅ Burner bonus (Top 1%).

✅ Governance (burn-weighted, stake-age, vote caps).

✅ Per-collection cap (20,000 NFTs) + Global cap (1B NFTs: 750M term, 250M perm).

✅ Safe-revoke for admin if AGC takes over.

✅ Upgradeable (UUPS).

ERC20 (CATA) + NFT staking + internal treasury vault

Permissionless collection registration (registerCollection)

Immutable 90/9/1 fee split (burn / treasury / deployer)

Surcharge escrow for UNVERIFIED collections (refund / forfeit)

Full staking (term & permanent), batch stake/unstake, harvest, governance, burner bookkeeping,
top-collections maintenance, top-burner bonus distribution, admin controls, pause/rescue, etc.


Upgradeable core that mints CATA rewards for:

- Unverified collections (custodial staking)

- Verified blue-chips (non-custodial registration)

Secured by two guardian councils:

- GCSS (deployer council) protecting fee receiver (deployer)

- AGC  (admin council) protecting DEFAULT_ADMIN_ROLE (with safe-revoke)


✅ The latest full Catalyst project, upgradeable, modular, and aligned with the whitepaper.

✅ Including the Guardian Council Security System (GCSS/DRS) and Admin Guardian Council (AGC).

✅ Including blue-chip protocol logic (wallet registration model for high-value collections).

✅ Including the original modular governance system (BWCG, ConfigRegistry, ProposalExecutor, FeeManager, Treasury).

✅ Including the 1B NFT global cap (75% term, 25% permanent, 20k per collection cap).
